{"ast":null,"code":"/**\n * DOM manipulation utilities for Shape component\n *//**\n * Deep equals helper for comparing objects\n * @param {Object} obj1 - First object to compare\n * @param {Object} obj2 - Second object to compare\n * @returns {boolean} Whether the objects are deeply equal\n */export const deepEquals=(obj1,obj2)=>{// Handle null/undefined cases\nif(obj1===obj2)return true;if(obj1===null||obj2===null)return false;if(obj1===undefined||obj2===undefined)return false;// Compare object keys and values\nconst keys1=Object.keys(obj1||{});const keys2=Object.keys(obj2||{});if(keys1.length!==keys2.length)return false;return keys1.every(key=>{const val1=obj1[key];const val2=obj2[key];// Handle nested objects\nif(typeof val1==='object'&&typeof val2==='object'){return deepEquals(val1,val2);}return val1===val2;});};/**\n * Updates all SVG path elements affected by animation\n * @param {Set} affectedSegments - Set of segment IDs that need updating\n * @param {Object} shapeData - Shape configuration data\n * @param {Object} controlPoints - Current animated control point positions\n * @param {Object} position - Current animated position\n * @param {Object} segmentRefs - References to segment DOM elements\n * @param {Object} containerRef - Reference to container DOM element\n */export const updateAffectedSegments=(affectedSegments,shapeData,controlPoints,position,segmentRefs,containerRef)=>{// Track if we need to update the fill path\nlet updateFillPath=false;// For each affected segment, directly update its path data\naffectedSegments.forEach(segmentId=>{updateFillPath=true;// Any segment change requires fill path update\nconst pathElement=segmentRefs[segmentId];if(!pathElement)return;// Find the segment definition\nconst segment=shapeData.segments.find(s=>s.id===segmentId);if(!segment)return;// Generate new path data for this segment\nconst points=segment.points.map(pointId=>{// Get original point\nconst originalPoint=shapeData.controlPoints.find(cp=>cp.id===pointId);// Apply animated values if available\nconst animatedPoint={...originalPoint,...(controlPoints[pointId]||{})};// Apply position transform\nreturn{...animatedPoint,x:animatedPoint.x+(position?position.x:shapeData.position.svg.x),y:animatedPoint.y+(position?position.y:shapeData.position.svg.y)};});// Generate path data string\nlet pathData='';if(segment.type==='line'){const start=points[0];const end=points[1];pathData=`M ${start.x} ${start.y} L ${end.x} ${end.y}`;}else if(segment.type==='bezier'){const start=points[0];const control1=points[1];const control2=points[2];const end=points[3];pathData=`M ${start.x} ${start.y} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y}`;}// Directly set the path data attribute in the DOM\npathElement.setAttribute('d',pathData);});// Update the fill path if needed\nif(updateFillPath&&shapeData.fillPath){const fillPathElement=containerRef===null||containerRef===void 0?void 0:containerRef.querySelector('.shape-fill-path');if(fillPathElement){// Generate the path data using the updated control points\nlet pathData='';let firstPoint=null;// Build the path directly using the segments in order\n// This is better than collecting points and then creating a path\nlet firstSegmentAdded=false;// Process each segment in order\nshapeData.segments.forEach(segment=>{const points=segment.points.map(pointId=>{// Get original point\nconst originalPoint=shapeData.controlPoints.find(cp=>cp.id===pointId);// Apply animated values if available\nconst animatedPoint={...originalPoint,...(controlPoints[pointId]||{})};// Apply position transform\nreturn{...animatedPoint,x:animatedPoint.x+(position?position.x:shapeData.position.svg.x),y:animatedPoint.y+(position?position.y:shapeData.position.svg.y)};});// Add path commands based on segment type\nif(segment.type==='line'){const start=points[0];const end=points[1];if(!firstSegmentAdded){// First segment starts with a Move command\npathData+=`M ${start.x} ${start.y} L ${end.x} ${end.y} `;firstPoint=start;firstSegmentAdded=true;}else{// Subsequent segments continue from previous point\npathData+=`L ${end.x} ${end.y} `;}}else if(segment.type==='bezier'){const start=points[0];const control1=points[1];const control2=points[2];const end=points[3];if(!firstSegmentAdded){// First segment starts with a Move command\npathData+=`M ${start.x} ${start.y} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;firstPoint=start;firstSegmentAdded=true;}else{// Subsequent segments continue from previous point with just the curve part\npathData+=`C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;}}});// If shape is marked as closed, add Z command to close the path\nif(shapeData.closePath){pathData+='Z';}// Update the fill path with the new path data\nfillPathElement.setAttribute('d',pathData);}else{console.warn('Fill path element not found. Make sure it has class \"shape-fill-path\"');}}};/**\n * Calculates the SVG viewBox for the shape\n * @param {Object} svgPosition - Position within the SVG coordinate system\n * @param {number} width - Width of the shape\n * @param {number} height - Height of the shape\n * @param {Object} [shapeData] - Complete shape data including animations (optional)\n * @returns {string} SVG viewBox attribute value\n */export const calculateViewBox=(svgPosition,width,height,shapeData)=>{// Default padding (small margin around the shape)\nconst DEFAULT_PADDING=10;// If shapeData has an explicit viewBox property, use that directly\nif(shapeData&&shapeData.viewBox){// When viewBox is explicit, the SVG position should be treated as an offset from the origin\n// of the viewBox coordinate system. The yellow dot should be positioned at svgPosition\n// within the viewBox coordinate system.\nreturn shapeData.viewBox;}// If no shape data is provided, use default dimensions with small padding\nif(!shapeData){return`${-svgPosition.x-DEFAULT_PADDING} ${-svgPosition.y-DEFAULT_PADDING} ${width+DEFAULT_PADDING*2} ${height+DEFAULT_PADDING*2}`;}// Otherwise, use a simple viewBox based on dimensions with padding\n// Position the viewBox so that the position.svg coordinates are in the top-left\nconst padding=DEFAULT_PADDING;const viewBoxX=-svgPosition.x-padding;const viewBoxY=-svgPosition.y-padding;const viewBoxWidth=width+padding*2;const viewBoxHeight=height+padding*2;return`${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`;};","map":{"version":3,"names":["deepEquals","obj1","obj2","undefined","keys1","Object","keys","keys2","length","every","key","val1","val2","updateAffectedSegments","affectedSegments","shapeData","controlPoints","position","segmentRefs","containerRef","updateFillPath","forEach","segmentId","pathElement","segment","segments","find","s","id","points","map","pointId","originalPoint","cp","animatedPoint","x","svg","y","pathData","type","start","end","control1","control2","setAttribute","fillPath","fillPathElement","querySelector","firstPoint","firstSegmentAdded","closePath","console","warn","calculateViewBox","svgPosition","width","height","DEFAULT_PADDING","viewBox","padding","viewBoxX","viewBoxY","viewBoxWidth","viewBoxHeight"],"sources":["/home/melvinvanelderen/TestGrass/client/src/utils/shape/domUtils.js"],"sourcesContent":["/**\n * DOM manipulation utilities for Shape component\n */\n\n/**\n * Deep equals helper for comparing objects\n * @param {Object} obj1 - First object to compare\n * @param {Object} obj2 - Second object to compare\n * @returns {boolean} Whether the objects are deeply equal\n */\nexport const deepEquals = (obj1, obj2) => {\n  // Handle null/undefined cases\n  if (obj1 === obj2) return true;\n  if (obj1 === null || obj2 === null) return false;\n  if (obj1 === undefined || obj2 === undefined) return false;\n  \n  // Compare object keys and values\n  const keys1 = Object.keys(obj1 || {});\n  const keys2 = Object.keys(obj2 || {});\n  \n  if (keys1.length !== keys2.length) return false;\n  \n  return keys1.every(key => {\n    const val1 = obj1[key];\n    const val2 = obj2[key];\n    \n    // Handle nested objects\n    if (typeof val1 === 'object' && typeof val2 === 'object') {\n      return deepEquals(val1, val2);\n    }\n    \n    return val1 === val2;\n  });\n};\n\n/**\n * Updates all SVG path elements affected by animation\n * @param {Set} affectedSegments - Set of segment IDs that need updating\n * @param {Object} shapeData - Shape configuration data\n * @param {Object} controlPoints - Current animated control point positions\n * @param {Object} position - Current animated position\n * @param {Object} segmentRefs - References to segment DOM elements\n * @param {Object} containerRef - Reference to container DOM element\n */\nexport const updateAffectedSegments = (\n  affectedSegments, \n  shapeData, \n  controlPoints, \n  position, \n  segmentRefs, \n  containerRef\n) => {\n  // Track if we need to update the fill path\n  let updateFillPath = false;\n  \n  // For each affected segment, directly update its path data\n  affectedSegments.forEach(segmentId => {\n    updateFillPath = true; // Any segment change requires fill path update\n    \n    const pathElement = segmentRefs[segmentId];\n    if (!pathElement) return;\n    \n    // Find the segment definition\n    const segment = shapeData.segments.find(s => s.id === segmentId);\n    if (!segment) return;\n    \n    // Generate new path data for this segment\n    const points = segment.points.map(pointId => {\n      // Get original point\n      const originalPoint = shapeData.controlPoints.find(cp => cp.id === pointId);\n      \n      // Apply animated values if available\n      const animatedPoint = {\n        ...originalPoint,\n        ...(controlPoints[pointId] || {})\n      };\n      \n      // Apply position transform\n      return {\n        ...animatedPoint,\n        x: animatedPoint.x + (position ? position.x : shapeData.position.svg.x),\n        y: animatedPoint.y + (position ? position.y : shapeData.position.svg.y)\n      };\n    });\n    \n    // Generate path data string\n    let pathData = '';\n    if (segment.type === 'line') {\n      const start = points[0];\n      const end = points[1];\n      pathData = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n    } else if (segment.type === 'bezier') {\n      const start = points[0];\n      const control1 = points[1];\n      const control2 = points[2];\n      const end = points[3];\n      pathData = `M ${start.x} ${start.y} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y}`;\n    }\n    \n    // Directly set the path data attribute in the DOM\n    pathElement.setAttribute('d', pathData);\n  });\n  \n  // Update the fill path if needed\n  if (updateFillPath && shapeData.fillPath) {\n    const fillPathElement = containerRef?.querySelector('.shape-fill-path');\n    if (fillPathElement) {\n      // Generate the path data using the updated control points\n      let pathData = '';\n      let firstPoint = null;\n      \n      // Build the path directly using the segments in order\n      // This is better than collecting points and then creating a path\n      let firstSegmentAdded = false;\n      \n      // Process each segment in order\n      shapeData.segments.forEach((segment) => {\n        const points = segment.points.map(pointId => {\n          // Get original point\n          const originalPoint = shapeData.controlPoints.find(cp => cp.id === pointId);\n          \n          // Apply animated values if available\n          const animatedPoint = {\n            ...originalPoint,\n            ...(controlPoints[pointId] || {})\n          };\n          \n          // Apply position transform\n          return {\n            ...animatedPoint,\n            x: animatedPoint.x + (position ? position.x : shapeData.position.svg.x),\n            y: animatedPoint.y + (position ? position.y : shapeData.position.svg.y)\n          };\n        });\n        \n        // Add path commands based on segment type\n        if (segment.type === 'line') {\n          const start = points[0];\n          const end = points[1];\n          \n          if (!firstSegmentAdded) {\n            // First segment starts with a Move command\n            pathData += `M ${start.x} ${start.y} L ${end.x} ${end.y} `;\n            firstPoint = start;\n            firstSegmentAdded = true;\n          } else {\n            // Subsequent segments continue from previous point\n            pathData += `L ${end.x} ${end.y} `;\n          }\n        } else if (segment.type === 'bezier') {\n          const start = points[0];\n          const control1 = points[1];\n          const control2 = points[2];\n          const end = points[3];\n          \n          if (!firstSegmentAdded) {\n            // First segment starts with a Move command\n            pathData += `M ${start.x} ${start.y} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;\n            firstPoint = start;\n            firstSegmentAdded = true;\n          } else {\n            // Subsequent segments continue from previous point with just the curve part\n            pathData += `C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;\n          }\n        }\n      });\n      \n      // If shape is marked as closed, add Z command to close the path\n      if (shapeData.closePath) {\n        pathData += 'Z';\n      }\n      \n      // Update the fill path with the new path data\n      fillPathElement.setAttribute('d', pathData);\n    } else {\n      console.warn('Fill path element not found. Make sure it has class \"shape-fill-path\"');\n    }\n  }\n};\n\n/**\n * Calculates the SVG viewBox for the shape\n * @param {Object} svgPosition - Position within the SVG coordinate system\n * @param {number} width - Width of the shape\n * @param {number} height - Height of the shape\n * @param {Object} [shapeData] - Complete shape data including animations (optional)\n * @returns {string} SVG viewBox attribute value\n */\nexport const calculateViewBox = (svgPosition, width, height, shapeData) => {\n  // Default padding (small margin around the shape)\n  const DEFAULT_PADDING = 10;\n  \n  // If shapeData has an explicit viewBox property, use that directly\n  if (shapeData && shapeData.viewBox) {\n    // When viewBox is explicit, the SVG position should be treated as an offset from the origin\n    // of the viewBox coordinate system. The yellow dot should be positioned at svgPosition\n    // within the viewBox coordinate system.\n    return shapeData.viewBox;\n  }\n  \n  // If no shape data is provided, use default dimensions with small padding\n  if (!shapeData) {\n    return `${-svgPosition.x - DEFAULT_PADDING} ${-svgPosition.y - DEFAULT_PADDING} ${width + DEFAULT_PADDING * 2} ${height + DEFAULT_PADDING * 2}`;\n  }\n  \n  // Otherwise, use a simple viewBox based on dimensions with padding\n  // Position the viewBox so that the position.svg coordinates are in the top-left\n  const padding = DEFAULT_PADDING;\n  const viewBoxX = -svgPosition.x - padding;\n  const viewBoxY = -svgPosition.y - padding;\n  const viewBoxWidth = width + (padding * 2);\n  const viewBoxHeight = height + (padding * 2);\n  \n  return `${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`;\n};\n"],"mappings":"AAAA;AACA;AACA,GAEA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAA,UAAU,CAAGA,CAACC,IAAI,CAAEC,IAAI,GAAK,CACxC;AACA,GAAID,IAAI,GAAKC,IAAI,CAAE,MAAO,KAAI,CAC9B,GAAID,IAAI,GAAK,IAAI,EAAIC,IAAI,GAAK,IAAI,CAAE,MAAO,MAAK,CAChD,GAAID,IAAI,GAAKE,SAAS,EAAID,IAAI,GAAKC,SAAS,CAAE,MAAO,MAAK,CAE1D;AACA,KAAM,CAAAC,KAAK,CAAGC,MAAM,CAACC,IAAI,CAACL,IAAI,EAAI,CAAC,CAAC,CAAC,CACrC,KAAM,CAAAM,KAAK,CAAGF,MAAM,CAACC,IAAI,CAACJ,IAAI,EAAI,CAAC,CAAC,CAAC,CAErC,GAAIE,KAAK,CAACI,MAAM,GAAKD,KAAK,CAACC,MAAM,CAAE,MAAO,MAAK,CAE/C,MAAO,CAAAJ,KAAK,CAACK,KAAK,CAACC,GAAG,EAAI,CACxB,KAAM,CAAAC,IAAI,CAAGV,IAAI,CAACS,GAAG,CAAC,CACtB,KAAM,CAAAE,IAAI,CAAGV,IAAI,CAACQ,GAAG,CAAC,CAEtB;AACA,GAAI,MAAO,CAAAC,IAAI,GAAK,QAAQ,EAAI,MAAO,CAAAC,IAAI,GAAK,QAAQ,CAAE,CACxD,MAAO,CAAAZ,UAAU,CAACW,IAAI,CAAEC,IAAI,CAAC,CAC/B,CAEA,MAAO,CAAAD,IAAI,GAAKC,IAAI,CACtB,CAAC,CAAC,CACJ,CAAC,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAC,sBAAsB,CAAGA,CACpCC,gBAAgB,CAChBC,SAAS,CACTC,aAAa,CACbC,QAAQ,CACRC,WAAW,CACXC,YAAY,GACT,CACH;AACA,GAAI,CAAAC,cAAc,CAAG,KAAK,CAE1B;AACAN,gBAAgB,CAACO,OAAO,CAACC,SAAS,EAAI,CACpCF,cAAc,CAAG,IAAI,CAAE;AAEvB,KAAM,CAAAG,WAAW,CAAGL,WAAW,CAACI,SAAS,CAAC,CAC1C,GAAI,CAACC,WAAW,CAAE,OAElB;AACA,KAAM,CAAAC,OAAO,CAAGT,SAAS,CAACU,QAAQ,CAACC,IAAI,CAACC,CAAC,EAAIA,CAAC,CAACC,EAAE,GAAKN,SAAS,CAAC,CAChE,GAAI,CAACE,OAAO,CAAE,OAEd;AACA,KAAM,CAAAK,MAAM,CAAGL,OAAO,CAACK,MAAM,CAACC,GAAG,CAACC,OAAO,EAAI,CAC3C;AACA,KAAM,CAAAC,aAAa,CAAGjB,SAAS,CAACC,aAAa,CAACU,IAAI,CAACO,EAAE,EAAIA,EAAE,CAACL,EAAE,GAAKG,OAAO,CAAC,CAE3E;AACA,KAAM,CAAAG,aAAa,CAAG,CACpB,GAAGF,aAAa,CAChB,IAAIhB,aAAa,CAACe,OAAO,CAAC,EAAI,CAAC,CAAC,CAClC,CAAC,CAED;AACA,MAAO,CACL,GAAGG,aAAa,CAChBC,CAAC,CAAED,aAAa,CAACC,CAAC,EAAIlB,QAAQ,CAAGA,QAAQ,CAACkB,CAAC,CAAGpB,SAAS,CAACE,QAAQ,CAACmB,GAAG,CAACD,CAAC,CAAC,CACvEE,CAAC,CAAEH,aAAa,CAACG,CAAC,EAAIpB,QAAQ,CAAGA,QAAQ,CAACoB,CAAC,CAAGtB,SAAS,CAACE,QAAQ,CAACmB,GAAG,CAACC,CAAC,CACxE,CAAC,CACH,CAAC,CAAC,CAEF;AACA,GAAI,CAAAC,QAAQ,CAAG,EAAE,CACjB,GAAId,OAAO,CAACe,IAAI,GAAK,MAAM,CAAE,CAC3B,KAAM,CAAAC,KAAK,CAAGX,MAAM,CAAC,CAAC,CAAC,CACvB,KAAM,CAAAY,GAAG,CAAGZ,MAAM,CAAC,CAAC,CAAC,CACrBS,QAAQ,CAAG,KAAKE,KAAK,CAACL,CAAC,IAAIK,KAAK,CAACH,CAAC,MAAMI,GAAG,CAACN,CAAC,IAAIM,GAAG,CAACJ,CAAC,EAAE,CAC1D,CAAC,IAAM,IAAIb,OAAO,CAACe,IAAI,GAAK,QAAQ,CAAE,CACpC,KAAM,CAAAC,KAAK,CAAGX,MAAM,CAAC,CAAC,CAAC,CACvB,KAAM,CAAAa,QAAQ,CAAGb,MAAM,CAAC,CAAC,CAAC,CAC1B,KAAM,CAAAc,QAAQ,CAAGd,MAAM,CAAC,CAAC,CAAC,CAC1B,KAAM,CAAAY,GAAG,CAAGZ,MAAM,CAAC,CAAC,CAAC,CACrBS,QAAQ,CAAG,KAAKE,KAAK,CAACL,CAAC,IAAIK,KAAK,CAACH,CAAC,MAAMK,QAAQ,CAACP,CAAC,IAAIO,QAAQ,CAACL,CAAC,KAAKM,QAAQ,CAACR,CAAC,IAAIQ,QAAQ,CAACN,CAAC,KAAKI,GAAG,CAACN,CAAC,IAAIM,GAAG,CAACJ,CAAC,EAAE,CACpH,CAEA;AACAd,WAAW,CAACqB,YAAY,CAAC,GAAG,CAAEN,QAAQ,CAAC,CACzC,CAAC,CAAC,CAEF;AACA,GAAIlB,cAAc,EAAIL,SAAS,CAAC8B,QAAQ,CAAE,CACxC,KAAM,CAAAC,eAAe,CAAG3B,YAAY,SAAZA,YAAY,iBAAZA,YAAY,CAAE4B,aAAa,CAAC,kBAAkB,CAAC,CACvE,GAAID,eAAe,CAAE,CACnB;AACA,GAAI,CAAAR,QAAQ,CAAG,EAAE,CACjB,GAAI,CAAAU,UAAU,CAAG,IAAI,CAErB;AACA;AACA,GAAI,CAAAC,iBAAiB,CAAG,KAAK,CAE7B;AACAlC,SAAS,CAACU,QAAQ,CAACJ,OAAO,CAAEG,OAAO,EAAK,CACtC,KAAM,CAAAK,MAAM,CAAGL,OAAO,CAACK,MAAM,CAACC,GAAG,CAACC,OAAO,EAAI,CAC3C;AACA,KAAM,CAAAC,aAAa,CAAGjB,SAAS,CAACC,aAAa,CAACU,IAAI,CAACO,EAAE,EAAIA,EAAE,CAACL,EAAE,GAAKG,OAAO,CAAC,CAE3E;AACA,KAAM,CAAAG,aAAa,CAAG,CACpB,GAAGF,aAAa,CAChB,IAAIhB,aAAa,CAACe,OAAO,CAAC,EAAI,CAAC,CAAC,CAClC,CAAC,CAED;AACA,MAAO,CACL,GAAGG,aAAa,CAChBC,CAAC,CAAED,aAAa,CAACC,CAAC,EAAIlB,QAAQ,CAAGA,QAAQ,CAACkB,CAAC,CAAGpB,SAAS,CAACE,QAAQ,CAACmB,GAAG,CAACD,CAAC,CAAC,CACvEE,CAAC,CAAEH,aAAa,CAACG,CAAC,EAAIpB,QAAQ,CAAGA,QAAQ,CAACoB,CAAC,CAAGtB,SAAS,CAACE,QAAQ,CAACmB,GAAG,CAACC,CAAC,CACxE,CAAC,CACH,CAAC,CAAC,CAEF;AACA,GAAIb,OAAO,CAACe,IAAI,GAAK,MAAM,CAAE,CAC3B,KAAM,CAAAC,KAAK,CAAGX,MAAM,CAAC,CAAC,CAAC,CACvB,KAAM,CAAAY,GAAG,CAAGZ,MAAM,CAAC,CAAC,CAAC,CAErB,GAAI,CAACoB,iBAAiB,CAAE,CACtB;AACAX,QAAQ,EAAI,KAAKE,KAAK,CAACL,CAAC,IAAIK,KAAK,CAACH,CAAC,MAAMI,GAAG,CAACN,CAAC,IAAIM,GAAG,CAACJ,CAAC,GAAG,CAC1DW,UAAU,CAAGR,KAAK,CAClBS,iBAAiB,CAAG,IAAI,CAC1B,CAAC,IAAM,CACL;AACAX,QAAQ,EAAI,KAAKG,GAAG,CAACN,CAAC,IAAIM,GAAG,CAACJ,CAAC,GAAG,CACpC,CACF,CAAC,IAAM,IAAIb,OAAO,CAACe,IAAI,GAAK,QAAQ,CAAE,CACpC,KAAM,CAAAC,KAAK,CAAGX,MAAM,CAAC,CAAC,CAAC,CACvB,KAAM,CAAAa,QAAQ,CAAGb,MAAM,CAAC,CAAC,CAAC,CAC1B,KAAM,CAAAc,QAAQ,CAAGd,MAAM,CAAC,CAAC,CAAC,CAC1B,KAAM,CAAAY,GAAG,CAAGZ,MAAM,CAAC,CAAC,CAAC,CAErB,GAAI,CAACoB,iBAAiB,CAAE,CACtB;AACAX,QAAQ,EAAI,KAAKE,KAAK,CAACL,CAAC,IAAIK,KAAK,CAACH,CAAC,MAAMK,QAAQ,CAACP,CAAC,IAAIO,QAAQ,CAACL,CAAC,KAAKM,QAAQ,CAACR,CAAC,IAAIQ,QAAQ,CAACN,CAAC,KAAKI,GAAG,CAACN,CAAC,IAAIM,GAAG,CAACJ,CAAC,GAAG,CACpHW,UAAU,CAAGR,KAAK,CAClBS,iBAAiB,CAAG,IAAI,CAC1B,CAAC,IAAM,CACL;AACAX,QAAQ,EAAI,KAAKI,QAAQ,CAACP,CAAC,IAAIO,QAAQ,CAACL,CAAC,KAAKM,QAAQ,CAACR,CAAC,IAAIQ,QAAQ,CAACN,CAAC,KAAKI,GAAG,CAACN,CAAC,IAAIM,GAAG,CAACJ,CAAC,GAAG,CAC9F,CACF,CACF,CAAC,CAAC,CAEF;AACA,GAAItB,SAAS,CAACmC,SAAS,CAAE,CACvBZ,QAAQ,EAAI,GAAG,CACjB,CAEA;AACAQ,eAAe,CAACF,YAAY,CAAC,GAAG,CAAEN,QAAQ,CAAC,CAC7C,CAAC,IAAM,CACLa,OAAO,CAACC,IAAI,CAAC,uEAAuE,CAAC,CACvF,CACF,CACF,CAAC,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAC,gBAAgB,CAAGA,CAACC,WAAW,CAAEC,KAAK,CAAEC,MAAM,CAAEzC,SAAS,GAAK,CACzE;AACA,KAAM,CAAA0C,eAAe,CAAG,EAAE,CAE1B;AACA,GAAI1C,SAAS,EAAIA,SAAS,CAAC2C,OAAO,CAAE,CAClC;AACA;AACA;AACA,MAAO,CAAA3C,SAAS,CAAC2C,OAAO,CAC1B,CAEA;AACA,GAAI,CAAC3C,SAAS,CAAE,CACd,MAAO,GAAG,CAACuC,WAAW,CAACnB,CAAC,CAAGsB,eAAe,IAAI,CAACH,WAAW,CAACjB,CAAC,CAAGoB,eAAe,IAAIF,KAAK,CAAGE,eAAe,CAAG,CAAC,IAAID,MAAM,CAAGC,eAAe,CAAG,CAAC,EAAE,CACjJ,CAEA;AACA;AACA,KAAM,CAAAE,OAAO,CAAGF,eAAe,CAC/B,KAAM,CAAAG,QAAQ,CAAG,CAACN,WAAW,CAACnB,CAAC,CAAGwB,OAAO,CACzC,KAAM,CAAAE,QAAQ,CAAG,CAACP,WAAW,CAACjB,CAAC,CAAGsB,OAAO,CACzC,KAAM,CAAAG,YAAY,CAAGP,KAAK,CAAII,OAAO,CAAG,CAAE,CAC1C,KAAM,CAAAI,aAAa,CAAGP,MAAM,CAAIG,OAAO,CAAG,CAAE,CAE5C,MAAO,GAAGC,QAAQ,IAAIC,QAAQ,IAAIC,YAAY,IAAIC,aAAa,EAAE,CACnE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}