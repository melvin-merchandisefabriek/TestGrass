{"ast":null,"code":"/**\n * Utility functions for handling shape modifications from external sources\n *//**\n * Applies modifications from a modifications object to a shape\n * @param {Object} shape - The original shape object\n * @param {Object} modifications - Modification specifications\n * @returns {Object} Modified shape object\n */export const applyShapeModifications=(shape,modifications)=>{if(!shape||!modifications)return shape;// Create a deep copy to avoid mutating the original\nconst modifiedShape=JSON.parse(JSON.stringify(shape));// Apply position modifications\nif(modifications.modifyPosition){// Support svg and global keys for unified SVG logic\nif(modifications.modifyPosition.svg){if(!modifiedShape.position)modifiedShape.position={};modifiedShape.position.svg={...modifications.modifyPosition.svg};}if(modifications.modifyPosition.global){if(!modifiedShape.position)modifiedShape.position={};modifiedShape.position.global={...modifications.modifyPosition.global};}// Legacy: if x/y provided at top level, apply to global\nif(typeof modifications.modifyPosition.x==='number'||typeof modifications.modifyPosition.y==='number'){var _modifiedShape$positi;if((_modifiedShape$positi=modifiedShape.position)!==null&&_modifiedShape$positi!==void 0&&_modifiedShape$positi.global){modifiedShape.position.global.x+=modifications.modifyPosition.x||0;modifiedShape.position.global.y+=modifications.modifyPosition.y||0;}}}// Apply control point modifications\nif(modifications.modifyControlPoints){Object.entries(modifications.modifyControlPoints).forEach(_ref=>{let[pointId,changes]=_ref;const controlPoint=modifiedShape.controlPoints.find(point=>point.id===pointId);if(controlPoint){if(changes.xOffset)controlPoint.x+=changes.xOffset;if(changes.yOffset)controlPoint.y+=changes.yOffset;}});}// Apply style modifications\nif(modifications.styleChanges){Object.entries(modifications.styleChanges).forEach(_ref2=>{let[segmentId,newStyle]=_ref2;const segment=modifiedShape.segments.find(seg=>seg.id===segmentId);if(segment){segment.style={...segment.style,...newStyle};}});}// Apply main style from modifications if present\nif(modifications.style){modifiedShape.style={...modifiedShape.style,...modifications.style};}// Apply fillPath and closePath from modifications if present\nif(typeof modifications.fillPath!=='undefined'){modifiedShape.fillPath=modifications.fillPath;}if(typeof modifications.closePath!=='undefined'){modifiedShape.closePath=modifications.closePath;}// Copy viewBox if present in modifications\nif(modifications.viewBox){modifiedShape.viewBox=modifications.viewBox;}// Copy width and height if present in modifications\nif(typeof modifications.width!=='undefined'){modifiedShape.width=modifications.width;}if(typeof modifications.height!=='undefined'){modifiedShape.height=modifications.height;}// Apply display options from modifications if present\nif(modifications.displayOptions){modifiedShape.displayOptions={...(modifiedShape.displayOptions||{}),...modifications.displayOptions};}// --- Merge or preserve variables field ---\nif(shape.variables||modifications.variables){// Support both array and object forms\nlet baseVars=shape.variables||[];let modVars=modifications.variables||[];// Convert to array of objects if needed\nif(!Array.isArray(baseVars))baseVars=[baseVars];if(!Array.isArray(modVars))modVars=[modVars];// Merge arrays, with modifications taking precedence for duplicate keys\nconst varMap={};baseVars.forEach(obj=>{const key=Object.keys(obj)[0];varMap[key]=obj[key];});modVars.forEach(obj=>{const key=Object.keys(obj)[0];varMap[key]=obj[key];});// Rebuild as array of objects\nmodifiedShape.variables=Object.entries(varMap).map(_ref3=>{let[k,v]=_ref3;return{[k]:v};});}// Process style templates with animation variables\nif(modifications.style){// Process each style property for template expressions\nObject.keys(modifications.style).forEach(key=>{const value=modifications.style[key];if(typeof value==='string'&&value.includes('${')){// This is a template string that needs to be processed during animation\nif(!modifications.animations){modifications.animations={styleAnimations:{}};}else if(!modifications.animations.styleAnimations){modifications.animations.styleAnimations={};}// Store this as a style animation expression\nmodifications.animations.styleAnimations[key]=value;// For the initial value, use a placeholder\nmodifications.style[key]=value.replace(/\\${(.*?)}/g,'0');}});}// Set up animations from the modifications\nif(modifications.animations){// Create or update animations structure in the shape data\nmodifiedShape.animations={duration:modifications.animations.duration||5,loops:modifications.animations.loops||0,controlPointAnimations:{},styleAnimations:modifications.animations.styleAnimations||{}};// Copy control point animations directly from the modifications\nif(modifications.animations.controlPointAnimations){// Just directly copy the control point animations - no special handling needed\n// since we're only using expressions now\nmodifiedShape.animations.controlPointAnimations=JSON.parse(JSON.stringify(modifications.animations.controlPointAnimations));}// Add position animations if present\nif(modifications.animations.positionAnimations){modifiedShape.animations.positionAnimations=JSON.parse(JSON.stringify(modifications.animations.positionAnimations));}// Copy style animations if present\nif(modifications.animations.styleAnimations){modifiedShape.animations.styleAnimations=JSON.parse(JSON.stringify(modifications.animations.styleAnimations));}}return modifiedShape;};/**\n * Loads modifications from a modifications file\n * @param {string} modPath - Path to the modifications JSON file\n * @returns {Promise<Object>} - The loaded modifications\n */export const loadModifications=async modPath=>{try{const response=await fetch(modPath);if(!response.ok){throw new Error(`Failed to load modifications: ${response.status}`);}const data=await response.json();return data;}catch(error){console.error('Error loading modifications:',error);return null;}};","map":{"version":3,"names":["applyShapeModifications","shape","modifications","modifiedShape","JSON","parse","stringify","modifyPosition","svg","position","global","x","y","_modifiedShape$positi","modifyControlPoints","Object","entries","forEach","_ref","pointId","changes","controlPoint","controlPoints","find","point","id","xOffset","yOffset","styleChanges","_ref2","segmentId","newStyle","segment","segments","seg","style","fillPath","closePath","viewBox","width","height","displayOptions","variables","baseVars","modVars","Array","isArray","varMap","obj","key","keys","map","_ref3","k","v","value","includes","animations","styleAnimations","replace","duration","loops","controlPointAnimations","positionAnimations","loadModifications","modPath","response","fetch","ok","Error","status","data","json","error","console"],"sources":["/home/melvinvanelderen/TestGrass/client/src/utils/shape/modificationUtils.js"],"sourcesContent":["/**\n * Utility functions for handling shape modifications from external sources\n */\n\n/**\n * Applies modifications from a modifications object to a shape\n * @param {Object} shape - The original shape object\n * @param {Object} modifications - Modification specifications\n * @returns {Object} Modified shape object\n */\nexport const applyShapeModifications = (shape, modifications) => {\n  if (!shape || !modifications) return shape;\n  \n  // Create a deep copy to avoid mutating the original\n  const modifiedShape = JSON.parse(JSON.stringify(shape));\n  \n  // Apply position modifications\n  if (modifications.modifyPosition) {\n    // Support svg and global keys for unified SVG logic\n    if (modifications.modifyPosition.svg) {\n      if (!modifiedShape.position) modifiedShape.position = {};\n      modifiedShape.position.svg = { ...modifications.modifyPosition.svg };\n    }\n    if (modifications.modifyPosition.global) {\n      if (!modifiedShape.position) modifiedShape.position = {};\n      modifiedShape.position.global = { ...modifications.modifyPosition.global };\n    }\n    // Legacy: if x/y provided at top level, apply to global\n    if (typeof modifications.modifyPosition.x === 'number' || typeof modifications.modifyPosition.y === 'number') {\n      if (modifiedShape.position?.global) {\n        modifiedShape.position.global.x += modifications.modifyPosition.x || 0;\n        modifiedShape.position.global.y += modifications.modifyPosition.y || 0;\n      }\n    }\n  }\n  \n  // Apply control point modifications\n  if (modifications.modifyControlPoints) {\n    Object.entries(modifications.modifyControlPoints).forEach(([pointId, changes]) => {\n      const controlPoint = modifiedShape.controlPoints.find(point => point.id === pointId);\n      if (controlPoint) {\n        if (changes.xOffset) controlPoint.x += changes.xOffset;\n        if (changes.yOffset) controlPoint.y += changes.yOffset;\n      }\n    });\n  }\n  \n  // Apply style modifications\n  if (modifications.styleChanges) {\n    Object.entries(modifications.styleChanges).forEach(([segmentId, newStyle]) => {\n      const segment = modifiedShape.segments.find(seg => seg.id === segmentId);\n      if (segment) {\n        segment.style = { ...segment.style, ...newStyle };\n      }\n    });\n  }\n  \n  // Apply main style from modifications if present\n  if (modifications.style) {\n    modifiedShape.style = { ...modifiedShape.style, ...modifications.style };\n  }\n  \n  // Apply fillPath and closePath from modifications if present\n  if (typeof modifications.fillPath !== 'undefined') {\n    modifiedShape.fillPath = modifications.fillPath;\n  }\n  \n  if (typeof modifications.closePath !== 'undefined') {\n    modifiedShape.closePath = modifications.closePath;\n  }\n  \n  // Copy viewBox if present in modifications\n  if (modifications.viewBox) {\n    modifiedShape.viewBox = modifications.viewBox;\n  }\n  \n  // Copy width and height if present in modifications\n  if (typeof modifications.width !== 'undefined') {\n    modifiedShape.width = modifications.width;\n  }\n  \n  if (typeof modifications.height !== 'undefined') {\n    modifiedShape.height = modifications.height;\n  }\n  \n  // Apply display options from modifications if present\n  if (modifications.displayOptions) {\n    modifiedShape.displayOptions = {\n      ...modifiedShape.displayOptions || {},\n      ...modifications.displayOptions\n    };\n  }\n  \n  // --- Merge or preserve variables field ---\n  if (shape.variables || modifications.variables) {\n    // Support both array and object forms\n    let baseVars = shape.variables || [];\n    let modVars = modifications.variables || [];\n    // Convert to array of objects if needed\n    if (!Array.isArray(baseVars)) baseVars = [baseVars];\n    if (!Array.isArray(modVars)) modVars = [modVars];\n    // Merge arrays, with modifications taking precedence for duplicate keys\n    const varMap = {};\n    baseVars.forEach(obj => {\n      const key = Object.keys(obj)[0];\n      varMap[key] = obj[key];\n    });\n    modVars.forEach(obj => {\n      const key = Object.keys(obj)[0];\n      varMap[key] = obj[key];\n    });\n    // Rebuild as array of objects\n    modifiedShape.variables = Object.entries(varMap).map(([k, v]) => ({ [k]: v }));\n  }\n  \n  // Process style templates with animation variables\n  if (modifications.style) {\n    // Process each style property for template expressions\n    Object.keys(modifications.style).forEach(key => {\n      const value = modifications.style[key];\n      if (typeof value === 'string' && value.includes('${')) {\n        // This is a template string that needs to be processed during animation\n        if (!modifications.animations) {\n          modifications.animations = { styleAnimations: {} };\n        } else if (!modifications.animations.styleAnimations) {\n          modifications.animations.styleAnimations = {};\n        }\n        \n        // Store this as a style animation expression\n        modifications.animations.styleAnimations[key] = value;\n        \n        // For the initial value, use a placeholder\n        modifications.style[key] = value.replace(/\\${(.*?)}/g, '0');\n      }\n    });\n  }\n  \n  // Set up animations from the modifications\n  if (modifications.animations) {\n    // Create or update animations structure in the shape data\n    modifiedShape.animations = {\n      duration: modifications.animations.duration || 5,\n      loops: modifications.animations.loops || 0,\n      controlPointAnimations: {},\n      styleAnimations: modifications.animations.styleAnimations || {}\n    };\n    \n    // Copy control point animations directly from the modifications\n    if (modifications.animations.controlPointAnimations) {\n      // Just directly copy the control point animations - no special handling needed\n      // since we're only using expressions now\n      modifiedShape.animations.controlPointAnimations = JSON.parse(\n        JSON.stringify(modifications.animations.controlPointAnimations)\n      );\n    }\n    \n    // Add position animations if present\n    if (modifications.animations.positionAnimations) {\n      modifiedShape.animations.positionAnimations = \n        JSON.parse(JSON.stringify(modifications.animations.positionAnimations));\n    }\n    \n    // Copy style animations if present\n    if (modifications.animations.styleAnimations) {\n      modifiedShape.animations.styleAnimations = \n        JSON.parse(JSON.stringify(modifications.animations.styleAnimations));\n    }\n  }\n  \n  return modifiedShape;\n};\n\n/**\n * Loads modifications from a modifications file\n * @param {string} modPath - Path to the modifications JSON file\n * @returns {Promise<Object>} - The loaded modifications\n */\nexport const loadModifications = async (modPath) => {\n  try {\n    const response = await fetch(modPath);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to load modifications: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error loading modifications:', error);\n    return null;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}