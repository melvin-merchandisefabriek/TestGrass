{"ast":null,"code":"import React,{useState,useRef,useCallback,useEffect,useMemo}from'react';import{calculateControlPointPosition,calculateGlobalPosition,calculateViewBox,deepEquals,updateAffectedSegments,loadShapeData}from'../utils/shape';import{mergeDisplayOptions}from'../utils/shape/displayUtils';// Default simple shape data for fallback\nimport{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const defaultShapeData={id:\"shape-default\",name:\"Default Shape\",width:200,height:200,position:{svg:{x:0,y:0},global:{x:100,y:100}},displayOptions:{showControlPoints:true,showAnchorPoints:true,showPositionAnchor:true,showBorder:true},controlPoints:[{id:\"cp-1\",x:50,y:50,type:\"anchor\"},{id:\"cp-2\",x:150,y:50,type:\"anchor\"},{id:\"cp-3\",x:150,y:150,type:\"anchor\"},{id:\"cp-4\",x:50,y:150,type:\"anchor\"}],segments:[{id:\"seg-1\",type:\"line\",points:[\"cp-1\",\"cp-2\"],style:{stroke:\"#ffffff\",strokeWidth:2}},{id:\"seg-2\",type:\"line\",points:[\"cp-2\",\"cp-3\"],style:{stroke:\"#ffffff\",strokeWidth:2}},{id:\"seg-3\",type:\"line\",points:[\"cp-3\",\"cp-4\"],style:{stroke:\"#ffffff\",strokeWidth:2}},{id:\"seg-4\",type:\"line\",points:[\"cp-4\",\"cp-1\"],style:{stroke:\"#ffffff\",strokeWidth:2}}],fillPath:true,closePath:true,style:{fill:\"rgba(120, 200, 255, 0.3)\",stroke:\"#ffffff\",strokeWidth:1}};const Shape=_ref=>{let{filePath,modificationsPath,shapeData:providedShapeData,shapeModifications,onClick,renderAsGroup=false}=_ref;// State for storing the loaded shape data\nconst[shapeData,setShapeData]=useState(providedShapeData||defaultShapeData);// Apply in-memory modifications when they change\nuseEffect(()=>{if(shapeModifications&&filePath){// Dynamically import to avoid circular dependencies\nconst applyModifications=async()=>{try{const{applyShapeModifications}=await import('../utils/shape/modificationUtils');// Always reload the base shape to ensure we start fresh\nconst baseShape=await loadShapeData(filePath);// Apply the modifications to the freshly loaded base shape data\nconst modifiedData=applyShapeModifications(baseShape,shapeModifications);console.log('Applied in-memory modifications:',modifiedData);setShapeData(modifiedData);}catch(error){console.error('Error applying in-memory modifications:',error);}};applyModifications();}else if(shapeModifications&&shapeData){// Fall back to using current shapeData if no filePath is provided\nconst applyModifications=async()=>{try{const{applyShapeModifications}=await import('../utils/shape/modificationUtils');// Apply the modifications to the current shape data\nconst modifiedData=applyShapeModifications(shapeData,shapeModifications);console.log('Applied in-memory modifications:',modifiedData);setShapeData(modifiedData);}catch(error){console.error('Error applying in-memory modifications:',error);}};applyModifications();}},[shapeModifications,filePath]);// Load shape data from file path if provided\nuseEffect(()=>{// Skip loading from file if we're using in-memory modifications\nif(shapeModifications){return;}if(filePath){const loadData=async()=>{try{// Load the base shape data\nconst data=await loadShapeData(filePath);// If there's a modifications path, load and apply those modifications\nif(modificationsPath){try{// Import dynamically to avoid circular dependencies\nconst{loadModifications,applyShapeModifications}=await import('../utils/shape/modificationUtils');// Load the modifications file\nconst modifications=await loadModifications(modificationsPath);if(modifications){// Apply the modifications to the shape data\nconst modifiedData=applyShapeModifications(data,modifications);console.log('Applied modifications:',modificationsPath,modifiedData);setShapeData(modifiedData);return;}}catch(modError){console.error('Error applying modifications:',modError);// Continue with unmodified data if modification fails\n}}// Set the regular shape data if no modifications or if modifications failed\nsetShapeData(data);}catch(error){console.error('Failed to load shape data:',error);// Fallback to default data if loading fails\nif(!providedShapeData){setShapeData(defaultShapeData);}}};loadData();}},[filePath,modificationsPath,providedShapeData,shapeModifications]);// State for animated control points and position\nconst[animatedControlPoints,setAnimatedControlPoints]=useState({});const[animatedPosition,setAnimatedPosition]=useState(null);// Store references for animation and DOM elements\nconst animationRef=useRef(null);const animationState=useRef({isAnimating:false,startTime:0,currentTime:0,lastUpdateTime:0});// Container ref for direct DOM updates\nconst containerRef=useRef(null);// Store refs for each segment path element for direct DOM updates\nconst segmentRefs=useRef({});// Helper function to find a control point by ID, with animation support\nconst findPoint=useCallback(pointId=>{// If this point has animated values, use those instead of the original\nif(animatedControlPoints[pointId]){return{...shapeData.controlPoints.find(cp=>cp.id===pointId),...animatedControlPoints[pointId]};}return shapeData.controlPoints.find(cp=>cp.id===pointId);},[shapeData.controlPoints,animatedControlPoints]);// Apply position transform to a point, with animation support\nconst transformPoint=useCallback(point=>{// Use animated position if available, otherwise use the original\nconst position=animatedPosition||shapeData.position.svg;// Apply the SVG position transform to adjust all coordinates\nreturn{...point,x:point.x+position.x,y:point.y+position.y};},[shapeData.position.svg,animatedPosition]);// Generate SVG paths for each segment with its own style\nconst renderSegments=()=>{return shapeData.segments.map(segment=>{const points=segment.points.map(pointId=>transformPoint(findPoint(pointId)));let pathData='';if(segment.type==='line'){const start=points[0];const end=points[1];pathData=`M ${start.x} ${start.y} L ${end.x} ${end.y}`;}else if(segment.type==='bezier'){const start=points[0];const control1=points[1];const control2=points[2];const end=points[3];pathData=`M ${start.x} ${start.y} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y}`;}return/*#__PURE__*/_jsx(\"path\",{ref:el=>{if(el)segmentRefs.current[segment.id]=el;},d:pathData,fill:shapeData.fillPath?\"none\":segment.style.fill||shapeData.style.fill||\"none\",stroke:segment.style.stroke||shapeData.style.stroke,strokeWidth:segment.style.strokeWidth||shapeData.style.strokeWidth},segment.id);});};// Render control points as small circles - memoized for performance\nconst renderControlPoints=useMemo(()=>{// Use our utility to get full display options with defaults\nconst displayOptions=mergeDisplayOptions(shapeData.displayOptions);const showControlPoints=displayOptions.showControlPoints;const showAnchorPoints=displayOptions.showAnchorPoints;// If both are hidden, return nothing\nif(!showControlPoints&&!showAnchorPoints){return null;}return shapeData.controlPoints.map(point=>{// Skip anchor points if they should be hidden\nif(point.type===\"anchor\"&&!showAnchorPoints){return null;}// Skip control points if they should be hidden\nif(point.type===\"control\"&&!showControlPoints){return null;}// Use the animated values if available\nconst animatedPoint=animatedControlPoints[point.id];const effectivePoint=animatedPoint?{...point,...animatedPoint}:point;const transformedPoint=transformPoint(effectivePoint);return/*#__PURE__*/_jsx(\"circle\",{cx:transformedPoint.x,cy:transformedPoint.y,r:point.type===\"anchor\"?4:2,fill:point.type===\"anchor\"?\"#ffffff\":\"#888888\",stroke:\"#444444\",strokeWidth:\"1\"},point.id);}).filter(Boolean);// Filter out null values\n},[shapeData.controlPoints,shapeData.displayOptions,animatedControlPoints,transformPoint]);// Render position anchor point (main anchor for the shape) - memoized for performance\nconst renderPositionAnchor=useMemo(()=>{// Use our utility to get full display options with defaults\nconst displayOptions=mergeDisplayOptions(shapeData.displayOptions);const showPositionAnchor=displayOptions.showPositionAnchor;if(!showPositionAnchor){return null;}// Use animated position if available\nconst position=animatedPosition||shapeData.position.svg;return/*#__PURE__*/_jsx(\"circle\",{cx:position.x,cy:position.y,r:6,fill:\"yellow\",stroke:\"black\",strokeWidth:\"1\"});},[shapeData.position.svg,shapeData.displayOptions,animatedPosition]);// Render control point names - memoized for performance\nconst renderControlPointNames=useMemo(()=>{// Use our utility to get full display options with defaults\nconst displayOptions=mergeDisplayOptions(shapeData.displayOptions);const showControlPointNames=displayOptions.showControlPointNames;const showControlPoints=displayOptions.showControlPoints;const showAnchorPoints=displayOptions.showAnchorPoints;// If names are not shown, or no points are shown, return nothing\nif(!showControlPointNames||!showControlPoints&&!showAnchorPoints){return null;}return shapeData.controlPoints.map(point=>{// Skip anchor points if they should be hidden\nif(point.type===\"anchor\"&&!showAnchorPoints){return null;}// Skip control points if they should be hidden\nif(point.type===\"control\"&&!showControlPoints){return null;}// Use the animated values if available\nconst animatedPoint=animatedControlPoints[point.id];const effectivePoint=animatedPoint?{...point,...animatedPoint}:point;const transformedPoint=transformPoint(effectivePoint);return/*#__PURE__*/_jsx(\"text\",{x:transformedPoint.x+6// Offset slightly from the point\n,y:transformedPoint.y-6,fontSize:\"10\",fill:\"#ffffff\",stroke:\"#000000\",strokeWidth:\"0.5\",paintOrder:\"stroke\",children:point.id},`name-${point.id}`);}).filter(Boolean);// Filter out null values\n},[shapeData.controlPoints,shapeData.displayOptions,animatedControlPoints,transformPoint]);// State for animated style properties\nconst[animatedStyle,setAnimatedStyle]=useState({});// Animation update function\nconst updateAnimationValues=currentTime=>{var _shapeData$animations,_shapeData$animations2,_shapeData$animations3,_shapeData$animations4;// Track which segments need to be redrawn\nconst affectedSegments=new Set();// Process control point animations\nconst newAnimatedControlPoints={...animatedControlPoints};if((_shapeData$animations=shapeData.animations)!==null&&_shapeData$animations!==void 0&&_shapeData$animations.controlPointAnimations){Object.entries(shapeData.animations.controlPointAnimations).forEach(_ref2=>{let[pointId,animation]=_ref2;// Find the segments that use this control point\nshapeData.segments.forEach(segment=>{if(segment.points.includes(pointId)){affectedSegments.add(segment.id);}});// Calculate new position for this control point\nconst animatedValues=calculateControlPointPosition(pointId,animation,currentTime,shapeData.animations.duration,shapeData.controlPoints,shapeData// Pass the entire shape data to access top-level variables\n);if(animatedValues){newAnimatedControlPoints[pointId]=animatedValues;}});}// Process style animations if present\nif((_shapeData$animations2=shapeData.animations)!==null&&_shapeData$animations2!==void 0&&_shapeData$animations2.styleAnimations){const{calculateStyleProperties}=require('../utils/shape/animationUtils');const newAnimatedStyle=calculateStyleProperties(shapeData.animations.styleAnimations,currentTime,shapeData.animations.duration,shapeData// Pass shapeData for custom variables\n);// Update animated style if changed\nif(!deepEquals(animatedStyle,newAnimatedStyle)){setAnimatedStyle(newAnimatedStyle);}// All segments are potentially affected by style changes\nshapeData.segments.forEach(segment=>{affectedSegments.add(segment.id);});}// Similarly process global position animations\nlet newAnimatedPosition=animatedPosition;if((_shapeData$animations3=shapeData.animations)!==null&&_shapeData$animations3!==void 0&&(_shapeData$animations4=_shapeData$animations3.positionAnimations)!==null&&_shapeData$animations4!==void 0&&_shapeData$animations4.global){const posAnimation=shapeData.animations.positionAnimations.global;// Calculate new global position\nconst calculatedPosition=calculateGlobalPosition(posAnimation,currentTime);if(calculatedPosition){newAnimatedPosition=calculatedPosition;// All segments are affected by position changes\nshapeData.segments.forEach(segment=>{affectedSegments.add(segment.id);});}}// Update state only if the values have changed\nif(!deepEquals(animatedControlPoints,newAnimatedControlPoints)){setAnimatedControlPoints(newAnimatedControlPoints);}if(!deepEquals(animatedPosition,newAnimatedPosition)){setAnimatedPosition(newAnimatedPosition);}// Direct update of affected segments in the DOM\nupdateAffectedSegments(affectedSegments,shapeData,newAnimatedControlPoints,newAnimatedPosition,segmentRefs.current,containerRef.current);};// Animation loop using requestAnimationFrame\nconst animationLoop=timestamp=>{if(!animationState.current.isAnimating)return;// Calculate the current time in the animation cycle\nconst elapsedTime=(timestamp-animationState.current.startTime)/1000;// convert to seconds\nconst duration=shapeData.animations.duration;const loops=shapeData.animations.loops;// Log animation state occasionally (every 30 frames)\nif(Math.floor(elapsedTime*30)%30===0){console.log('Animation running:',elapsedTime.toFixed(1)+'s');}// Calculate the effective animation time based on loops\n// If loops is 0, it's infinite, so just use modulo of duration\n// If it's a specific number, check if we've exceeded total duration\nlet normalizedTime;if(loops===0){normalizedTime=elapsedTime%duration;}else{const totalDuration=loops*duration;if(elapsedTime>=totalDuration){// Animation complete, clean up and exit\nanimationState.current.isAnimating=false;cancelAnimationFrame(animationRef.current);return;}normalizedTime=elapsedTime%duration;}// Update animated values\nupdateAnimationValues(normalizedTime);// Store last update time\nanimationState.current.lastUpdateTime=timestamp;// Request next frame\nanimationRef.current=requestAnimationFrame(animationLoop);};// Initialize animation\nconst initializeAnimation=()=>{// Only initialize if animation isn't already running and animation data exists\nif(!animationState.current.isAnimating&&shapeData.animations){animationState.current.isAnimating=true;animationState.current.startTime=performance.now();animationState.current.lastUpdateTime=performance.now();animationRef.current=requestAnimationFrame(animationLoop);}};// Setup and cleanup animation when component mounts/unmounts or when shapeData changes\nuseEffect(()=>{// If animation is defined in shapeData, set up the animation system\nif(shapeData.animations){console.log('Setting up animation system...');initializeAnimation();return()=>{// Cleanup function to stop animation when component unmounts\nif(animationRef.current){console.log('Cleaning up animation...');cancelAnimationFrame(animationRef.current);animationState.current.isAnimating=false;}};}},[shapeData]);// Note: animationLoop and other functions are defined inside the component, so they're implicitly dependencies\nif(renderAsGroup){// Render as SVG group for unified SVG\n// Only apply svg position as a transform if explicitly provided in shapeModifications\nlet svgPos={x:0,y:0};if(shapeModifications&&shapeModifications.modifyPosition&&shapeModifications.modifyPosition.svg){svgPos=shapeModifications.modifyPosition.svg;}return/*#__PURE__*/_jsxs(\"g\",{ref:containerRef,className:\"shape-component\",transform:`translate(${svgPos.x},${svgPos.y})`,onClick:onClick,children:[shapeData.fillPath&&/*#__PURE__*/_jsx(\"path\",{className:\"shape-fill-path\",d:(()=>{let pathData='';let firstPoint=null;shapeData.segments.forEach((segment,index)=>{const points=segment.points.map(pointId=>{const point=findPoint(pointId);return transformPoint(point);});if(index===0){if(segment.type==='line'){const start=points[0];const end=points[1];pathData+=`M ${start.x} ${start.y} L ${end.x} ${end.y} `;firstPoint=start;}else if(segment.type==='bezier'){const start=points[0];const control1=points[1];const control2=points[2];const end=points[3];pathData+=`M ${start.x} ${start.y} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;firstPoint=start;}}else{if(segment.type==='line'){const end=points[1];pathData+=`L ${end.x} ${end.y} `;}else if(segment.type==='bezier'){const control1=points[1];const control2=points[2];const end=points[3];pathData+=`C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;}}});if(shapeData.closePath){pathData+='Z';}return pathData;})(),fill:animatedStyle.fill||shapeData.style.fill||\"none\",stroke:animatedStyle.stroke||shapeData.style.stroke,strokeWidth:animatedStyle.strokeWidth||shapeData.style.strokeWidth}),renderPositionAnchor,renderSegments(),renderControlPoints,renderControlPointNames]});}return/*#__PURE__*/_jsx(\"div\",{ref:containerRef,className:\"shape-component\",style:{position:'absolute',top:`${(animatedPosition===null||animatedPosition===void 0?void 0:animatedPosition.y)||shapeData.position.global.y}px`,left:`${(animatedPosition===null||animatedPosition===void 0?void 0:animatedPosition.x)||shapeData.position.global.x}px`,transition:'top 0.01s linear, left 0.01s linear'// Smooth out position updates\n},children:/*#__PURE__*/_jsxs(\"svg\",{width:shapeData.width,height:shapeData.height,viewBox:calculateViewBox(shapeData.position.svg,shapeData.width,shapeData.height,shapeData),xmlns:\"http://www.w3.org/2000/svg\",style:{border:mergeDisplayOptions(shapeData.displayOptions).showBorder?'1px dashed rgba(255, 255, 255, 0.3)':'none'},onClick:onClick,children:[shapeData.fillPath&&/*#__PURE__*/_jsx(\"path\",{className:\"shape-fill-path\",onClick:onClick,style:{cursor:onClick?'pointer':'default'},d:(()=>{let pathData='';let firstPoint=null;// Always use the actual segment definitions for all shapes to preserve exact appearance\n// Process each segment to preserve bezier curves and lines correctly\nshapeData.segments.forEach((segment,index)=>{const points=segment.points.map(pointId=>{const point=findPoint(pointId);return transformPoint(point);});if(index===0){// First segment - start with a move command\nif(segment.type==='line'){const start=points[0];const end=points[1];pathData+=`M ${start.x} ${start.y} L ${end.x} ${end.y} `;firstPoint=start;}else if(segment.type==='bezier'){const start=points[0];const control1=points[1];const control2=points[2];const end=points[3];pathData+=`M ${start.x} ${start.y} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;firstPoint=start;}}else{// Subsequent segments - continue the path\nif(segment.type==='line'){const end=points[1];pathData+=`L ${end.x} ${end.y} `;}else if(segment.type==='bezier'){const control1=points[1];const control2=points[2];const end=points[3];pathData+=`C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;}}});// Add the Z command to close the path if requested\nif(shapeData.closePath){pathData+='Z';}// Log path data for debugging specific shapes\nif(shapeData.id==='menu-square'||shapeData.id==='triangle-shape'){console.log(`Generated bezier-preserving path for ${shapeData.id}: ${pathData}`);}return pathData;})(),fill:animatedStyle.fill||shapeData.style.fill||\"none\",stroke:animatedStyle.stroke||shapeData.style.stroke,strokeWidth:animatedStyle.strokeWidth||shapeData.style.strokeWidth}),renderPositionAnchor,renderSegments(),renderControlPoints,renderControlPointNames]})});};export default Shape;","map":{"version":3,"names":["React","useState","useRef","useCallback","useEffect","useMemo","calculateControlPointPosition","calculateGlobalPosition","calculateViewBox","deepEquals","updateAffectedSegments","loadShapeData","mergeDisplayOptions","jsx","_jsx","jsxs","_jsxs","defaultShapeData","id","name","width","height","position","svg","x","y","global","displayOptions","showControlPoints","showAnchorPoints","showPositionAnchor","showBorder","controlPoints","type","segments","points","style","stroke","strokeWidth","fillPath","closePath","fill","Shape","_ref","filePath","modificationsPath","shapeData","providedShapeData","shapeModifications","onClick","renderAsGroup","setShapeData","applyModifications","applyShapeModifications","baseShape","modifiedData","console","log","error","loadData","data","loadModifications","modifications","modError","animatedControlPoints","setAnimatedControlPoints","animatedPosition","setAnimatedPosition","animationRef","animationState","isAnimating","startTime","currentTime","lastUpdateTime","containerRef","segmentRefs","findPoint","pointId","find","cp","transformPoint","point","renderSegments","map","segment","pathData","start","end","control1","control2","ref","el","current","d","renderControlPoints","animatedPoint","effectivePoint","transformedPoint","cx","cy","r","filter","Boolean","renderPositionAnchor","renderControlPointNames","showControlPointNames","fontSize","paintOrder","children","animatedStyle","setAnimatedStyle","updateAnimationValues","_shapeData$animations","_shapeData$animations2","_shapeData$animations3","_shapeData$animations4","affectedSegments","Set","newAnimatedControlPoints","animations","controlPointAnimations","Object","entries","forEach","_ref2","animation","includes","add","animatedValues","duration","styleAnimations","calculateStyleProperties","require","newAnimatedStyle","newAnimatedPosition","positionAnimations","posAnimation","calculatedPosition","animationLoop","timestamp","elapsedTime","loops","Math","floor","toFixed","normalizedTime","totalDuration","cancelAnimationFrame","requestAnimationFrame","initializeAnimation","performance","now","svgPos","modifyPosition","className","transform","firstPoint","index","top","left","transition","viewBox","xmlns","border","cursor"],"sources":["/home/melvinvanelderen/TestGrass/client/src/components/Shape.js"],"sourcesContent":["import React, { useState, useRef, useCallback, useEffect, useMemo } from 'react';\nimport { \n  calculateControlPointPosition,\n  calculateGlobalPosition,\n  calculateViewBox,\n  deepEquals,\n  updateAffectedSegments,\n  loadShapeData\n} from '../utils/shape';\nimport { mergeDisplayOptions } from '../utils/shape/displayUtils';\n\n// Default simple shape data for fallback\nconst defaultShapeData = {\n  id: \"shape-default\",\n  name: \"Default Shape\",\n  width: 200,\n  height: 200,\n  position: {\n    svg: { x: 0, y: 0 },\n    global: { x: 100, y: 100 }\n  },\n  displayOptions: {\n    showControlPoints: true,\n    showAnchorPoints: true,\n    showPositionAnchor: true,\n    showBorder: true\n  },\n  controlPoints: [\n    { id: \"cp-1\", x: 50, y: 50, type: \"anchor\" },\n    { id: \"cp-2\", x: 150, y: 50, type: \"anchor\" },\n    { id: \"cp-3\", x: 150, y: 150, type: \"anchor\" },\n    { id: \"cp-4\", x: 50, y: 150, type: \"anchor\" }\n  ],\n  segments: [\n    {\n      id: \"seg-1\",\n      type: \"line\",\n      points: [\"cp-1\", \"cp-2\"],\n      style: { stroke: \"#ffffff\", strokeWidth: 2 }\n    },\n    {\n      id: \"seg-2\",\n      type: \"line\",\n      points: [\"cp-2\", \"cp-3\"],\n      style: { stroke: \"#ffffff\", strokeWidth: 2 }\n    },\n    {\n      id: \"seg-3\",\n      type: \"line\",\n      points: [\"cp-3\", \"cp-4\"],\n      style: { stroke: \"#ffffff\", strokeWidth: 2 }\n    },\n    {\n      id: \"seg-4\",\n      type: \"line\",\n      points: [\"cp-4\", \"cp-1\"],\n      style: { stroke: \"#ffffff\", strokeWidth: 2 }\n    }\n  ],\n  fillPath: true,\n  closePath: true,\n  style: {\n    fill: \"rgba(120, 200, 255, 0.3)\",\n    stroke: \"#ffffff\",\n    strokeWidth: 1\n  }\n};\n\nconst Shape = ({ filePath, modificationsPath, shapeData: providedShapeData, shapeModifications, onClick, renderAsGroup = false }) => {\n  // State for storing the loaded shape data\n  const [shapeData, setShapeData] = useState(providedShapeData || defaultShapeData);\n  \n  // Apply in-memory modifications when they change\n  useEffect(() => {\n    if (shapeModifications && filePath) {\n      // Dynamically import to avoid circular dependencies\n      const applyModifications = async () => {\n        try {\n          const { applyShapeModifications } = await import('../utils/shape/modificationUtils');\n          \n          // Always reload the base shape to ensure we start fresh\n          const baseShape = await loadShapeData(filePath);\n          \n          // Apply the modifications to the freshly loaded base shape data\n          const modifiedData = applyShapeModifications(baseShape, shapeModifications);\n          console.log('Applied in-memory modifications:', modifiedData);\n          setShapeData(modifiedData);\n        } catch (error) {\n          console.error('Error applying in-memory modifications:', error);\n        }\n      };\n      \n      applyModifications();\n    } else if (shapeModifications && shapeData) {\n      // Fall back to using current shapeData if no filePath is provided\n      const applyModifications = async () => {\n        try {\n          const { applyShapeModifications } = await import('../utils/shape/modificationUtils');\n          \n          // Apply the modifications to the current shape data\n          const modifiedData = applyShapeModifications(shapeData, shapeModifications);\n          console.log('Applied in-memory modifications:', modifiedData);\n          setShapeData(modifiedData);\n        } catch (error) {\n          console.error('Error applying in-memory modifications:', error);\n        }\n      };\n      \n      applyModifications();\n    }\n  }, [shapeModifications, filePath]);\n  \n  // Load shape data from file path if provided\n  useEffect(() => {\n    // Skip loading from file if we're using in-memory modifications\n    if (shapeModifications) {\n      return;\n    }\n    \n    if (filePath) {\n      const loadData = async () => {\n        try {\n          // Load the base shape data\n          const data = await loadShapeData(filePath);\n          \n          // If there's a modifications path, load and apply those modifications\n          if (modificationsPath) {\n            try {\n              // Import dynamically to avoid circular dependencies\n              const { loadModifications, applyShapeModifications } = await import('../utils/shape/modificationUtils');\n              \n              // Load the modifications file\n              const modifications = await loadModifications(modificationsPath);\n              \n              if (modifications) {\n                // Apply the modifications to the shape data\n                const modifiedData = applyShapeModifications(data, modifications);\n                console.log('Applied modifications:', modificationsPath, modifiedData);\n                setShapeData(modifiedData);\n                return;\n              }\n            } catch (modError) {\n              console.error('Error applying modifications:', modError);\n              // Continue with unmodified data if modification fails\n            }\n          }\n          \n          // Set the regular shape data if no modifications or if modifications failed\n          setShapeData(data);\n        } catch (error) {\n          console.error('Failed to load shape data:', error);\n          // Fallback to default data if loading fails\n          if (!providedShapeData) {\n            setShapeData(defaultShapeData);\n          }\n        }\n      };\n      \n      loadData();\n    }\n  }, [filePath, modificationsPath, providedShapeData, shapeModifications]);\n  // State for animated control points and position\n  const [animatedControlPoints, setAnimatedControlPoints] = useState({});\n  const [animatedPosition, setAnimatedPosition] = useState(null);\n  \n  // Store references for animation and DOM elements\n  const animationRef = useRef(null);\n  const animationState = useRef({\n    isAnimating: false,\n    startTime: 0,\n    currentTime: 0,\n    lastUpdateTime: 0\n  });\n  \n  // Container ref for direct DOM updates\n  const containerRef = useRef(null);\n  \n  // Store refs for each segment path element for direct DOM updates\n  const segmentRefs = useRef({});\n  \n  // Helper function to find a control point by ID, with animation support\n  const findPoint = useCallback((pointId) => {\n    // If this point has animated values, use those instead of the original\n    if (animatedControlPoints[pointId]) {\n      return {\n        ...shapeData.controlPoints.find(cp => cp.id === pointId),\n        ...animatedControlPoints[pointId]\n      };\n    }\n    return shapeData.controlPoints.find(cp => cp.id === pointId);\n  }, [shapeData.controlPoints, animatedControlPoints]);\n  \n  // Apply position transform to a point, with animation support\n  const transformPoint = useCallback((point) => {\n    // Use animated position if available, otherwise use the original\n    const position = animatedPosition || shapeData.position.svg;\n    \n    // Apply the SVG position transform to adjust all coordinates\n    return {\n      ...point,\n      x: point.x + position.x,\n      y: point.y + position.y\n    };\n  }, [shapeData.position.svg, animatedPosition]);\n  \n  // Generate SVG paths for each segment with its own style\n  const renderSegments = () => {\n    return shapeData.segments.map(segment => {\n      const points = segment.points.map(pointId => transformPoint(findPoint(pointId)));\n      let pathData = '';\n      \n      if (segment.type === 'line') {\n        const start = points[0];\n        const end = points[1];\n        pathData = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n      } else if (segment.type === 'bezier') {\n        const start = points[0];\n        const control1 = points[1];\n        const control2 = points[2];\n        const end = points[3];\n        pathData = `M ${start.x} ${start.y} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y}`;\n      }\n      \n      return (\n        <path\n          key={segment.id}\n          ref={el => { if (el) segmentRefs.current[segment.id] = el; }}\n          d={pathData}\n          fill={shapeData.fillPath ? \"none\" : (segment.style.fill || shapeData.style.fill || \"none\")}\n          stroke={segment.style.stroke || shapeData.style.stroke}\n          strokeWidth={segment.style.strokeWidth || shapeData.style.strokeWidth}\n        />\n      );\n    });\n  };\n  \n  // Render control points as small circles - memoized for performance\n  const renderControlPoints = useMemo(() => {\n    // Use our utility to get full display options with defaults\n    const displayOptions = mergeDisplayOptions(shapeData.displayOptions);\n    const showControlPoints = displayOptions.showControlPoints;\n    const showAnchorPoints = displayOptions.showAnchorPoints;\n\n    // If both are hidden, return nothing\n    if (!showControlPoints && !showAnchorPoints) {\n      return null;\n    }\n    \n    return shapeData.controlPoints.map(point => {\n      // Skip anchor points if they should be hidden\n      if (point.type === \"anchor\" && !showAnchorPoints) {\n        return null;\n      }\n      \n      // Skip control points if they should be hidden\n      if (point.type === \"control\" && !showControlPoints) {\n        return null;\n      }\n      \n      // Use the animated values if available\n      const animatedPoint = animatedControlPoints[point.id];\n      const effectivePoint = animatedPoint ? \n        { ...point, ...animatedPoint } :\n        point;\n      \n      const transformedPoint = transformPoint(effectivePoint);\n      \n      return (\n        <circle\n          key={point.id}\n          cx={transformedPoint.x}\n          cy={transformedPoint.y}\n          r={point.type === \"anchor\" ? 4 : 2}\n          fill={point.type === \"anchor\" ? \"#ffffff\" : \"#888888\"}\n          stroke=\"#444444\"\n          strokeWidth=\"1\"\n        />\n      );\n    }).filter(Boolean); // Filter out null values\n  }, [shapeData.controlPoints, shapeData.displayOptions, animatedControlPoints, transformPoint]);\n  \n  // Render position anchor point (main anchor for the shape) - memoized for performance\n  const renderPositionAnchor = useMemo(() => {\n    // Use our utility to get full display options with defaults\n    const displayOptions = mergeDisplayOptions(shapeData.displayOptions);\n    const showPositionAnchor = displayOptions.showPositionAnchor;\n    \n    if (!showPositionAnchor) {\n      return null;\n    }\n    \n    // Use animated position if available\n    const position = animatedPosition || shapeData.position.svg;\n    \n    return (\n      <circle\n        cx={position.x}\n        cy={position.y}\n        r={6}\n        fill=\"yellow\"\n        stroke=\"black\"\n        strokeWidth=\"1\"\n      />\n    );\n  }, [shapeData.position.svg, shapeData.displayOptions, animatedPosition]);\n  \n  // Render control point names - memoized for performance\n  const renderControlPointNames = useMemo(() => {\n    // Use our utility to get full display options with defaults\n    const displayOptions = mergeDisplayOptions(shapeData.displayOptions);\n    const showControlPointNames = displayOptions.showControlPointNames;\n    const showControlPoints = displayOptions.showControlPoints;\n    const showAnchorPoints = displayOptions.showAnchorPoints;\n\n    // If names are not shown, or no points are shown, return nothing\n    if (!showControlPointNames || (!showControlPoints && !showAnchorPoints)) {\n      return null;\n    }\n    \n    return shapeData.controlPoints.map(point => {\n      // Skip anchor points if they should be hidden\n      if (point.type === \"anchor\" && !showAnchorPoints) {\n        return null;\n      }\n      \n      // Skip control points if they should be hidden\n      if (point.type === \"control\" && !showControlPoints) {\n        return null;\n      }\n      \n      // Use the animated values if available\n      const animatedPoint = animatedControlPoints[point.id];\n      const effectivePoint = animatedPoint ? \n        { ...point, ...animatedPoint } :\n        point;\n      \n      const transformedPoint = transformPoint(effectivePoint);\n      \n      return (\n        <text\n          key={`name-${point.id}`}\n          x={transformedPoint.x + 6} // Offset slightly from the point\n          y={transformedPoint.y - 6}\n          fontSize=\"10\"\n          fill=\"#ffffff\"\n          stroke=\"#000000\"\n          strokeWidth=\"0.5\"\n          paintOrder=\"stroke\"\n        >\n          {point.id}\n        </text>\n      );\n    }).filter(Boolean); // Filter out null values\n  }, [shapeData.controlPoints, shapeData.displayOptions, animatedControlPoints, transformPoint]);\n\n  // State for animated style properties\n  const [animatedStyle, setAnimatedStyle] = useState({});\n  \n  // Animation update function\n  const updateAnimationValues = (currentTime) => {\n    // Track which segments need to be redrawn\n    const affectedSegments = new Set();\n    \n    // Process control point animations\n    const newAnimatedControlPoints = { ...animatedControlPoints };\n    \n    if (shapeData.animations?.controlPointAnimations) {\n      Object.entries(shapeData.animations.controlPointAnimations).forEach(([pointId, animation]) => {\n        // Find the segments that use this control point\n        shapeData.segments.forEach(segment => {\n          if (segment.points.includes(pointId)) {\n            affectedSegments.add(segment.id);\n          }\n        });\n        \n        // Calculate new position for this control point\n        const animatedValues = calculateControlPointPosition(\n          pointId, \n          animation, \n          currentTime, \n          shapeData.animations.duration,\n          shapeData.controlPoints,\n          shapeData  // Pass the entire shape data to access top-level variables\n        );\n        if (animatedValues) {\n          newAnimatedControlPoints[pointId] = animatedValues;\n        }\n      });\n    }\n    \n    // Process style animations if present\n    if (shapeData.animations?.styleAnimations) {\n      const { calculateStyleProperties } = require('../utils/shape/animationUtils');\n      const newAnimatedStyle = calculateStyleProperties(\n        shapeData.animations.styleAnimations,\n        currentTime,\n        shapeData.animations.duration,\n        shapeData // Pass shapeData for custom variables\n      );\n      \n      // Update animated style if changed\n      if (!deepEquals(animatedStyle, newAnimatedStyle)) {\n        setAnimatedStyle(newAnimatedStyle);\n      }\n      \n      // All segments are potentially affected by style changes\n      shapeData.segments.forEach(segment => {\n        affectedSegments.add(segment.id);\n      });\n    }\n    \n    // Similarly process global position animations\n    let newAnimatedPosition = animatedPosition;\n    if (shapeData.animations?.positionAnimations?.global) {\n      const posAnimation = shapeData.animations.positionAnimations.global;\n      \n      // Calculate new global position\n      const calculatedPosition = calculateGlobalPosition(posAnimation, currentTime);\n      if (calculatedPosition) {\n        newAnimatedPosition = calculatedPosition;\n        \n        // All segments are affected by position changes\n        shapeData.segments.forEach(segment => {\n          affectedSegments.add(segment.id);\n        });\n      }\n    }\n    \n    // Update state only if the values have changed\n    if (!deepEquals(animatedControlPoints, newAnimatedControlPoints)) {\n      setAnimatedControlPoints(newAnimatedControlPoints);\n    }\n    \n    if (!deepEquals(animatedPosition, newAnimatedPosition)) {\n      setAnimatedPosition(newAnimatedPosition);\n    }\n    \n    // Direct update of affected segments in the DOM\n    updateAffectedSegments(\n      affectedSegments, \n      shapeData, \n      newAnimatedControlPoints, \n      newAnimatedPosition, \n      segmentRefs.current, \n      containerRef.current\n    );\n  };\n\n  // Animation loop using requestAnimationFrame\n  const animationLoop = (timestamp) => {\n    if (!animationState.current.isAnimating) return;\n    \n    // Calculate the current time in the animation cycle\n    const elapsedTime = (timestamp - animationState.current.startTime) / 1000; // convert to seconds\n    const duration = shapeData.animations.duration;\n    const loops = shapeData.animations.loops;\n    \n    // Log animation state occasionally (every 30 frames)\n    if (Math.floor(elapsedTime * 30) % 30 === 0) {\n      console.log('Animation running:', elapsedTime.toFixed(1) + 's');\n    }\n    \n    // Calculate the effective animation time based on loops\n    // If loops is 0, it's infinite, so just use modulo of duration\n    // If it's a specific number, check if we've exceeded total duration\n    let normalizedTime;\n    if (loops === 0) {\n      normalizedTime = elapsedTime % duration;\n    } else {\n      const totalDuration = loops * duration;\n      if (elapsedTime >= totalDuration) {\n        // Animation complete, clean up and exit\n        animationState.current.isAnimating = false;\n        cancelAnimationFrame(animationRef.current);\n        return;\n      }\n      normalizedTime = elapsedTime % duration;\n    }\n    \n    // Update animated values\n    updateAnimationValues(normalizedTime);\n    \n    // Store last update time\n    animationState.current.lastUpdateTime = timestamp;\n    \n    // Request next frame\n    animationRef.current = requestAnimationFrame(animationLoop);\n  };\n\n  // Initialize animation\n  const initializeAnimation = () => {\n    // Only initialize if animation isn't already running and animation data exists\n    if (!animationState.current.isAnimating && shapeData.animations) {\n      animationState.current.isAnimating = true;\n      animationState.current.startTime = performance.now();\n      animationState.current.lastUpdateTime = performance.now();\n      animationRef.current = requestAnimationFrame(animationLoop);\n    }\n  };\n  \n  // Setup and cleanup animation when component mounts/unmounts or when shapeData changes\n  useEffect(() => {\n    // If animation is defined in shapeData, set up the animation system\n    if (shapeData.animations) {\n      console.log('Setting up animation system...');\n      initializeAnimation();\n      return () => {\n        // Cleanup function to stop animation when component unmounts\n        if (animationRef.current) {\n          console.log('Cleaning up animation...');\n          cancelAnimationFrame(animationRef.current);\n          animationState.current.isAnimating = false;\n        }\n      };\n    }\n  }, [shapeData]); // Note: animationLoop and other functions are defined inside the component, so they're implicitly dependencies\n  \n  if (renderAsGroup) {\n    // Render as SVG group for unified SVG\n    // Only apply svg position as a transform if explicitly provided in shapeModifications\n    let svgPos = { x: 0, y: 0 };\n    if (shapeModifications && shapeModifications.modifyPosition && shapeModifications.modifyPosition.svg) {\n      svgPos = shapeModifications.modifyPosition.svg;\n    }\n    return (\n      <g\n        ref={containerRef}\n        className=\"shape-component\"\n        transform={`translate(${svgPos.x},${svgPos.y})`}\n        onClick={onClick}\n      >\n        {/* If fillPath is true, render a single combined path with fill */}\n        {shapeData.fillPath && (\n          <path\n            className=\"shape-fill-path\"\n            d={(() => {\n              let pathData = '';\n              let firstPoint = null;\n              shapeData.segments.forEach((segment, index) => {\n                const points = segment.points.map(pointId => {\n                  const point = findPoint(pointId);\n                  return transformPoint(point);\n                });\n                if (index === 0) {\n                  if (segment.type === 'line') {\n                    const start = points[0];\n                    const end = points[1];\n                    pathData += `M ${start.x} ${start.y} L ${end.x} ${end.y} `;\n                    firstPoint = start;\n                  } else if (segment.type === 'bezier') {\n                    const start = points[0];\n                    const control1 = points[1];\n                    const control2 = points[2];\n                    const end = points[3];\n                    pathData += `M ${start.x} ${start.y} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;\n                    firstPoint = start;\n                  }\n                } else {\n                  if (segment.type === 'line') {\n                    const end = points[1];\n                    pathData += `L ${end.x} ${end.y} `;\n                  } else if (segment.type === 'bezier') {\n                    const control1 = points[1];\n                    const control2 = points[2];\n                    const end = points[3];\n                    pathData += `C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;\n                  }\n                }\n              });\n              if (shapeData.closePath) {\n                pathData += 'Z';\n              }\n              return pathData;\n            })()}\n            fill={animatedStyle.fill || shapeData.style.fill || \"none\"}\n            stroke={animatedStyle.stroke || shapeData.style.stroke}\n            strokeWidth={animatedStyle.strokeWidth || shapeData.style.strokeWidth}\n          />\n        )}\n        {renderPositionAnchor}\n        {renderSegments()}\n        {renderControlPoints}\n        {renderControlPointNames}\n      </g>\n    );\n  }\n\n  return (\n    <div \n      ref={containerRef}\n      className=\"shape-component\" \n      style={{ \n        position: 'absolute', \n        top: `${animatedPosition?.y || shapeData.position.global.y}px`, \n        left: `${animatedPosition?.x || shapeData.position.global.x}px`,\n        transition: 'top 0.01s linear, left 0.01s linear' // Smooth out position updates\n      }}\n    >\n      <svg \n        width={shapeData.width} \n        height={shapeData.height}\n        viewBox={calculateViewBox(shapeData.position.svg, shapeData.width, shapeData.height, shapeData)} \n        xmlns=\"http://www.w3.org/2000/svg\"\n        style={{ border: mergeDisplayOptions(shapeData.displayOptions).showBorder ? '1px dashed rgba(255, 255, 255, 0.3)' : 'none' }}\n        onClick={onClick}\n      >\n        {/* If fillPath is true, render a single combined path with fill */}\n        {shapeData.fillPath && (\n          <path\n            className=\"shape-fill-path\"\n            onClick={onClick}\n            style={{ cursor: onClick ? 'pointer' : 'default' }}\n            d={(() => {\n              let pathData = '';\n              let firstPoint = null;\n              \n              // Always use the actual segment definitions for all shapes to preserve exact appearance\n              // Process each segment to preserve bezier curves and lines correctly\n              shapeData.segments.forEach((segment, index) => {\n                const points = segment.points.map(pointId => {\n                  const point = findPoint(pointId);\n                  return transformPoint(point);\n                });\n                \n                if (index === 0) {\n                  // First segment - start with a move command\n                  if (segment.type === 'line') {\n                    const start = points[0];\n                    const end = points[1];\n                    pathData += `M ${start.x} ${start.y} L ${end.x} ${end.y} `;\n                    firstPoint = start;\n                  } else if (segment.type === 'bezier') {\n                    const start = points[0];\n                    const control1 = points[1];\n                    const control2 = points[2];\n                    const end = points[3];\n                    pathData += `M ${start.x} ${start.y} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;\n                    firstPoint = start;\n                  }\n                } else {\n                  // Subsequent segments - continue the path\n                  if (segment.type === 'line') {\n                    const end = points[1];\n                    pathData += `L ${end.x} ${end.y} `;\n                  } else if (segment.type === 'bezier') {\n                    const control1 = points[1];\n                    const control2 = points[2];\n                    const end = points[3];\n                    pathData += `C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;\n                  }\n                }\n              });\n              \n              // Add the Z command to close the path if requested\n              if (shapeData.closePath) {\n                pathData += 'Z';\n              }\n              \n              // Log path data for debugging specific shapes\n              if (shapeData.id === 'menu-square' || shapeData.id === 'triangle-shape') {\n                console.log(`Generated bezier-preserving path for ${shapeData.id}: ${pathData}`);\n              }\n              \n              return pathData;\n            })()}\n            fill={animatedStyle.fill || shapeData.style.fill || \"none\"}\n            stroke={animatedStyle.stroke || shapeData.style.stroke}\n            strokeWidth={animatedStyle.strokeWidth || shapeData.style.strokeWidth}\n          />\n        )}\n        \n        {/* Render position anchor point */}\n        {renderPositionAnchor}\n        \n        {/* Render each segment with its own style */}\n        {renderSegments()}\n        \n        {/* Render control points */}\n        {renderControlPoints}\n        \n        {/* Render control point names */}\n        {renderControlPointNames}\n      </svg>\n    </div>\n  );\n};\n\nexport default Shape;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}