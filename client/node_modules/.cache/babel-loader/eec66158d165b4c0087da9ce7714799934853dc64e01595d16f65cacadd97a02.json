{"ast":null,"code":"/**\n * Animation utility functions for Shape component\n */import{substituteVariables}from'./variableUtils';/**\n * Get standard animation variables for formulas\n * @param {number} currentTime - Current time in seconds\n * @param {number} duration - Total animation duration in seconds\n * @returns {Object} Variables for animation formulas\n */export const getAnimationVariables=(currentTime,duration)=>{return{t:currentTime,// Current time in seconds\nd:duration,// Total duration in seconds\nn:currentTime/duration,// Normalized time (0 to 1)\nPI:Math.PI,TWO_PI:2*Math.PI,sin:Math.sin,cos:Math.cos,tan:Math.tan,abs:Math.abs,min:Math.min,max:Math.max,sqrt:Math.sqrt,pow:Math.pow,floor:Math.floor,ceil:Math.ceil,round:Math.round,exp:Math.exp,log:Math.log,random:Math.random};};/**\n * Safely evaluates mathematical expressions\n * @param {string} expression - Mathematical expression to evaluate\n * @param {Object} variables - Variables to use in the expression\n * @returns {number|null} Result of the expression or null if error\n */export const evaluateExpression=(expression,variables)=>{try{if(typeof expression==='string'&&expression.includes('|var:')){const processedExpr=substituteVariables(expression,variables);if(processedExpr!==expression){expression=processedExpr;}}const safeFunction=new Function(...Object.keys(variables),`\n      \"use strict\";\n      return ${expression};\n    `);return safeFunction(...Object.values(variables));}catch(error){console.warn(`Error evaluating expression: ${expression}`,error);return null;}};/**\n * Calculates values based on mathematical formulas\n * @param {Object} formula - Formula configuration\n * @param {number} currentTime - Current time in seconds\n * @param {number} duration - Total animation duration in seconds\n * @returns {number|null} Calculated value or null if invalid formula\n */export const calculateFormula=(formula,currentTime,duration,shapeData)=>{if(!formula)return null;// Create common variables available to all formulas\nconst variables=getAnimationVariables(currentTime,duration);// Add top-level variables from the shape data if available\nif(shapeData&&shapeData.variables){// Handle array of objects format [{\"varName\": \"value\"}, ...]\nif(Array.isArray(shapeData.variables)){shapeData.variables.forEach(varObj=>{const key=Object.keys(varObj)[0];const value=varObj[key];variables[key]=typeof value==='number'?value:value;// Keep as is\n});}// Handle object format {\"varName\": \"value\", ...}\nelse if(typeof shapeData.variables==='object'){Object.entries(shapeData.variables).forEach(_ref=>{let[key,value]=_ref;variables[key]=typeof value==='number'?value:value;// Keep as is\n});}}// Only support expression-based formulas\nif(formula.expression){// Process any remaining |var:varName| references in the expression\nconst originalExpression=formula.expression;const processedExprString=substituteVariables(originalExpression,variables);// Log if expression was modified by variable substitution\nif(originalExpression!==processedExprString){// Use the processed expression for further operations\nformula={...formula,expression:processedExprString};}// Debug information for specific expressions that would use variables\nconst isWaveFormula=formula.expression.includes('baseY')||formula.expression.includes('amp1')||formula.expression.includes('amp2');// Add any custom variables defined in the formula\nif(formula.variables){Object.entries(formula.variables).forEach(_ref2=>{let[key,value]=_ref2;variables[key]=value;if(isWaveFormula){console.log(`- Added formula-specific variable ${key} = ${value}`);}});}// Process variable references in the expression\nconst processedExpression=substituteVariables(formula.expression,variables);const result=evaluateExpression(processedExpression,variables);if(isWaveFormula){console.log(`Wave formula evaluation result: ${result}`);}return result;}console.error('Invalid formula format. Must include an expression property:',formula);return null;};/**\n * Calculates animated position for a control point\n * @param {string} pointId - ID of the control point\n * @param {Object} animation - Animation configuration\n * @param {number} currentTime - Current animation time\n * @param {number} duration - Total animation duration\n * @param {Array} controlPoints - Array of control point definitions\n * @returns {Object|null} New position {x, y} or null if no animation\n *//**\n * Processes template strings with animation expressions\n * @param {string} template - Template string with ${...} expressions\n * @param {Object} variables - Animation variables to use\n * @returns {string} Processed string with evaluated expressions\n */export const processStyleTemplate=(template,variables)=>{if(!template||typeof template!=='string'||!template.includes('${')){return template;}try{// Replace ${...} expressions with evaluated results, after variable substitution\nreturn template.replace(/\\${(.*?)}/g,(match,expression)=>{// Substitute |var:...| in the expression before evaluating\nconst substituted=substituteVariables(expression,variables);const result=evaluateExpression(substituted,variables);return result!==null?result:0;});}catch(error){console.error('Error processing style template:',error);return template;}};/**\n * Calculates animated style properties based on templates\n * @param {Object} styleAnimations - Style animation templates\n * @param {number} currentTime - Current time in seconds\n * @param {number} duration - Total animation duration in seconds\n * @returns {Object} Animated style properties\n */export const calculateStyleProperties=(styleAnimations,currentTime,duration,shapeData)=>{if(!styleAnimations)return{};// Start with standard animation variables\nconst variables=getAnimationVariables(currentTime,duration);// Merge in custom variables from shapeData.variables (array or object)\nif(shapeData&&shapeData.variables){if(Array.isArray(shapeData.variables)){shapeData.variables.forEach(varObj=>{const key=Object.keys(varObj)[0];variables[key]=varObj[key];});}else if(typeof shapeData.variables==='object'){Object.entries(shapeData.variables).forEach(_ref3=>{let[key,value]=_ref3;variables[key]=value;});}}const result={};Object.entries(styleAnimations).forEach(_ref4=>{let[property,template]=_ref4;result[property]=processStyleTemplate(template,variables);});return result;};export const calculateControlPointPosition=(pointId,animation,currentTime,duration,controlPoints,shapeData)=>{const result={x:null,y:null};// Check for formula-based animation\nif(animation.formula){// Calculate X position if formula is provided\nif(animation.formula.x){result.x=calculateFormula(animation.formula.x,currentTime,duration,shapeData);}// Calculate Y position if formula is provided\nif(animation.formula.y){result.y=calculateFormula(animation.formula.y,currentTime,duration,shapeData);}}// If we still need x or y values, try to get them from keyframes\nif((result.x===null||result.y===null)&&animation.keyframes&&animation.keyframes.length>0){// Basic linear interpolation between keyframes\nconst keyframes=animation.keyframes;// Find the surrounding keyframes\nlet startKeyframe=keyframes[0];let endKeyframe=keyframes[keyframes.length-1];// Single keyframe case\nif(keyframes.length===1){if(result.x===null)result.x=keyframes[0].x;if(result.y===null)result.y=keyframes[0].y;}else{// Multiple keyframes\nfor(let i=0;i<keyframes.length-1;i++){if(keyframes[i].time<=currentTime&&keyframes[i+1].time>=currentTime){startKeyframe=keyframes[i];endKeyframe=keyframes[i+1];break;}}// If current time is before the first keyframe or after the last one,\n// use the closest keyframe's values directly\nif(currentTime<=keyframes[0].time){if(result.x===null)result.x=keyframes[0].x;if(result.y===null)result.y=keyframes[0].y;}else if(currentTime>=keyframes[keyframes.length-1].time){if(result.x===null)result.x=keyframes[keyframes.length-1].x;if(result.y===null)result.y=keyframes[keyframes.length-1].y;}else{// Calculate position by interpolating between keyframes\nconst timeDiff=endKeyframe.time-startKeyframe.time;const timeProgress=(currentTime-startKeyframe.time)/timeDiff;// Linear interpolation between the two keyframes, only for properties not set by formula\nif(result.x===null&&startKeyframe.x!==undefined&&endKeyframe.x!==undefined){result.x=startKeyframe.x+(endKeyframe.x-startKeyframe.x)*timeProgress;}if(result.y===null&&startKeyframe.y!==undefined&&endKeyframe.y!==undefined){result.y=startKeyframe.y+(endKeyframe.y-startKeyframe.y)*timeProgress;}}}}// If we successfully calculated at least one value\nif(result.x!==null||result.y!==null){// Fill in any missing values with defaults from the first control point\nconst originalPoint=controlPoints.find(cp=>cp.id===pointId);if(result.x===null&&originalPoint)result.x=originalPoint.x;if(result.y===null&&originalPoint)result.y=originalPoint.y;return result;}return null;};/**\n * Calculates the animated global position\n * @param {Object} animation - Global position animation configuration\n * @param {number} currentTime - Current animation time\n * @param {number} duration - Total animation duration\n * @returns {Object|null} New global position {x, y} or null\n */export const calculateGlobalPosition=(animation,currentTime,duration)=>{// Treat global position as a special case of control point animation\n// Create a default point with {x:0, y:0} to use as the base\nconst defaultPoint={id:'global',x:0,y:0};return calculateControlPointPosition('global',animation,currentTime,duration,[defaultPoint],null);};","map":{"version":3,"names":["substituteVariables","getAnimationVariables","currentTime","duration","t","d","n","PI","Math","TWO_PI","sin","cos","tan","abs","min","max","sqrt","pow","floor","ceil","round","exp","log","random","evaluateExpression","expression","variables","includes","processedExpr","safeFunction","Function","Object","keys","values","error","console","warn","calculateFormula","formula","shapeData","Array","isArray","forEach","varObj","key","value","entries","_ref","originalExpression","processedExprString","isWaveFormula","_ref2","processedExpression","result","processStyleTemplate","template","replace","match","substituted","calculateStyleProperties","styleAnimations","_ref3","_ref4","property","calculateControlPointPosition","pointId","animation","controlPoints","x","y","keyframes","length","startKeyframe","endKeyframe","i","time","timeDiff","timeProgress","undefined","originalPoint","find","cp","id","calculateGlobalPosition","defaultPoint"],"sources":["/home/melvinvanelderen/TestGrass/client/src/utils/shape/animationUtils.js"],"sourcesContent":["/**\n * Animation utility functions for Shape component\n */\n\nimport { substituteVariables } from './variableUtils';\n\n/**\n * Get standard animation variables for formulas\n * @param {number} currentTime - Current time in seconds\n * @param {number} duration - Total animation duration in seconds\n * @returns {Object} Variables for animation formulas\n */\nexport const getAnimationVariables = (currentTime, duration) => {\n  return {\n    t: currentTime,                     // Current time in seconds\n    d: duration,                        // Total duration in seconds\n    n: currentTime / duration,          // Normalized time (0 to 1)\n    PI: Math.PI,\n    TWO_PI: 2 * Math.PI,\n    sin: Math.sin,\n    cos: Math.cos,\n    tan: Math.tan,\n    abs: Math.abs,\n    min: Math.min,\n    max: Math.max,\n    sqrt: Math.sqrt,\n    pow: Math.pow,\n    floor: Math.floor,\n    ceil: Math.ceil,\n    round: Math.round,\n    exp: Math.exp,\n    log: Math.log,\n    random: Math.random\n  };\n};\n\n/**\n * Safely evaluates mathematical expressions\n * @param {string} expression - Mathematical expression to evaluate\n * @param {Object} variables - Variables to use in the expression\n * @returns {number|null} Result of the expression or null if error\n */\nexport const evaluateExpression = (expression, variables) => {\n  try {\n    if (typeof expression === 'string' && expression.includes('|var:')) {\n      const processedExpr = substituteVariables(expression, variables);\n      if (processedExpr !== expression) {\n        expression = processedExpr;\n      }\n    }\n    const safeFunction = new Function(...Object.keys(variables), `\n      \"use strict\";\n      return ${expression};\n    `);\n    return safeFunction(...Object.values(variables));\n  } catch (error) {\n    console.warn(`Error evaluating expression: ${expression}`, error);\n    return null;\n  }\n};\n\n/**\n * Calculates values based on mathematical formulas\n * @param {Object} formula - Formula configuration\n * @param {number} currentTime - Current time in seconds\n * @param {number} duration - Total animation duration in seconds\n * @returns {number|null} Calculated value or null if invalid formula\n */\nexport const calculateFormula = (formula, currentTime, duration, shapeData) => {\n  if (!formula) return null;\n\n  // Create common variables available to all formulas\n  const variables = getAnimationVariables(currentTime, duration);\n\n  // Add top-level variables from the shape data if available\n  if (shapeData && shapeData.variables) {\n    // Handle array of objects format [{\"varName\": \"value\"}, ...]\n    if (Array.isArray(shapeData.variables)) {\n      shapeData.variables.forEach(varObj => {\n        const key = Object.keys(varObj)[0];\n        const value = varObj[key];\n        variables[key] = typeof value === 'number' ? value : value; // Keep as is\n      });\n    } \n    // Handle object format {\"varName\": \"value\", ...}\n    else if (typeof shapeData.variables === 'object') {\n      Object.entries(shapeData.variables).forEach(([key, value]) => {\n        variables[key] = typeof value === 'number' ? value : value; // Keep as is\n      });\n    }\n  }\n\n  // Only support expression-based formulas\n  if (formula.expression) {\n    // Process any remaining |var:varName| references in the expression\n    const originalExpression = formula.expression;\n    const processedExprString = substituteVariables(originalExpression, variables);\n    \n    // Log if expression was modified by variable substitution\n    if (originalExpression !== processedExprString) {\n      // Use the processed expression for further operations\n      formula = { ...formula, expression: processedExprString };\n    }\n    \n    // Debug information for specific expressions that would use variables\n    const isWaveFormula = formula.expression.includes('baseY') || \n                          formula.expression.includes('amp1') ||\n                          formula.expression.includes('amp2');\n    \n    // Add any custom variables defined in the formula\n    if (formula.variables) {\n      Object.entries(formula.variables).forEach(([key, value]) => {\n        variables[key] = value;\n        \n        if (isWaveFormula) {\n          console.log(`- Added formula-specific variable ${key} = ${value}`);\n        }\n      });\n    }\n    \n    // Process variable references in the expression\n    const processedExpression = substituteVariables(formula.expression, variables);\n    \n    const result = evaluateExpression(processedExpression, variables);\n    \n    if (isWaveFormula) {\n      console.log(`Wave formula evaluation result: ${result}`);\n    }\n    \n    return result;\n  }\n  \n  console.error('Invalid formula format. Must include an expression property:', formula);\n  return null;\n};\n\n/**\n * Calculates animated position for a control point\n * @param {string} pointId - ID of the control point\n * @param {Object} animation - Animation configuration\n * @param {number} currentTime - Current animation time\n * @param {number} duration - Total animation duration\n * @param {Array} controlPoints - Array of control point definitions\n * @returns {Object|null} New position {x, y} or null if no animation\n */\n/**\n * Processes template strings with animation expressions\n * @param {string} template - Template string with ${...} expressions\n * @param {Object} variables - Animation variables to use\n * @returns {string} Processed string with evaluated expressions\n */\nexport const processStyleTemplate = (template, variables) => {\n  if (!template || typeof template !== 'string' || !template.includes('${')) {\n    return template;\n  }\n  try {\n    // Replace ${...} expressions with evaluated results, after variable substitution\n    return template.replace(/\\${(.*?)}/g, (match, expression) => {\n      // Substitute |var:...| in the expression before evaluating\n      const substituted = substituteVariables(expression, variables);\n      const result = evaluateExpression(substituted, variables);\n      return result !== null ? result : 0;\n    });\n  } catch (error) {\n    console.error('Error processing style template:', error);\n    return template;\n  }\n};\n\n/**\n * Calculates animated style properties based on templates\n * @param {Object} styleAnimations - Style animation templates\n * @param {number} currentTime - Current time in seconds\n * @param {number} duration - Total animation duration in seconds\n * @returns {Object} Animated style properties\n */\nexport const calculateStyleProperties = (styleAnimations, currentTime, duration, shapeData) => {\n  if (!styleAnimations) return {};\n  // Start with standard animation variables\n  const variables = getAnimationVariables(currentTime, duration);\n  // Merge in custom variables from shapeData.variables (array or object)\n  if (shapeData && shapeData.variables) {\n    if (Array.isArray(shapeData.variables)) {\n      shapeData.variables.forEach(varObj => {\n        const key = Object.keys(varObj)[0];\n        variables[key] = varObj[key];\n      });\n    } else if (typeof shapeData.variables === 'object') {\n      Object.entries(shapeData.variables).forEach(([key, value]) => {\n        variables[key] = value;\n      });\n    }\n  }\n  const result = {};\n  Object.entries(styleAnimations).forEach(([property, template]) => {\n    result[property] = processStyleTemplate(template, variables);\n  });\n  return result;\n};\n\nexport const calculateControlPointPosition = (pointId, animation, currentTime, duration, controlPoints, shapeData) => {\n  const result = { x: null, y: null };\n  \n  // Check for formula-based animation\n  if (animation.formula) {\n    // Calculate X position if formula is provided\n    if (animation.formula.x) {\n      result.x = calculateFormula(animation.formula.x, currentTime, duration, shapeData);\n    }\n    \n    // Calculate Y position if formula is provided\n    if (animation.formula.y) {\n      result.y = calculateFormula(animation.formula.y, currentTime, duration, shapeData);\n    }\n  }\n  \n  // If we still need x or y values, try to get them from keyframes\n  if ((result.x === null || result.y === null) && animation.keyframes && animation.keyframes.length > 0) {\n    // Basic linear interpolation between keyframes\n    const keyframes = animation.keyframes;\n    \n    // Find the surrounding keyframes\n    let startKeyframe = keyframes[0];\n    let endKeyframe = keyframes[keyframes.length - 1];\n    \n    // Single keyframe case\n    if (keyframes.length === 1) {\n      if (result.x === null) result.x = keyframes[0].x;\n      if (result.y === null) result.y = keyframes[0].y;\n    } else {\n      // Multiple keyframes\n      for (let i = 0; i < keyframes.length - 1; i++) {\n        if (keyframes[i].time <= currentTime && keyframes[i+1].time >= currentTime) {\n          startKeyframe = keyframes[i];\n          endKeyframe = keyframes[i+1];\n          break;\n        }\n      }\n      \n      // If current time is before the first keyframe or after the last one,\n      // use the closest keyframe's values directly\n      if (currentTime <= keyframes[0].time) {\n        if (result.x === null) result.x = keyframes[0].x;\n        if (result.y === null) result.y = keyframes[0].y;\n      } else if (currentTime >= keyframes[keyframes.length-1].time) {\n        if (result.x === null) result.x = keyframes[keyframes.length-1].x;\n        if (result.y === null) result.y = keyframes[keyframes.length-1].y;\n      } else {\n        // Calculate position by interpolating between keyframes\n        const timeDiff = endKeyframe.time - startKeyframe.time;\n        const timeProgress = (currentTime - startKeyframe.time) / timeDiff;\n        \n        // Linear interpolation between the two keyframes, only for properties not set by formula\n        if (result.x === null && startKeyframe.x !== undefined && endKeyframe.x !== undefined) {\n          result.x = startKeyframe.x + (endKeyframe.x - startKeyframe.x) * timeProgress;\n        }\n        \n        if (result.y === null && startKeyframe.y !== undefined && endKeyframe.y !== undefined) {\n          result.y = startKeyframe.y + (endKeyframe.y - startKeyframe.y) * timeProgress;\n        }\n      }\n    }\n  }\n  \n  // If we successfully calculated at least one value\n  if (result.x !== null || result.y !== null) {\n    // Fill in any missing values with defaults from the first control point\n    const originalPoint = controlPoints.find(cp => cp.id === pointId);\n    if (result.x === null && originalPoint) result.x = originalPoint.x;\n    if (result.y === null && originalPoint) result.y = originalPoint.y;\n    \n    return result;\n  }\n  \n  return null;\n};\n\n/**\n * Calculates the animated global position\n * @param {Object} animation - Global position animation configuration\n * @param {number} currentTime - Current animation time\n * @param {number} duration - Total animation duration\n * @returns {Object|null} New global position {x, y} or null\n */\nexport const calculateGlobalPosition = (animation, currentTime, duration) => {\n  // Treat global position as a special case of control point animation\n  // Create a default point with {x:0, y:0} to use as the base\n  const defaultPoint = { id: 'global', x: 0, y: 0 };\n  return calculateControlPointPosition('global', animation, currentTime, duration, [defaultPoint], null);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}