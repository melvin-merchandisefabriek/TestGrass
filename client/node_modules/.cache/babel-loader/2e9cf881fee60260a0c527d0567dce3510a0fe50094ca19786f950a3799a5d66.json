{"ast":null,"code":"// Simple, readable ear clipping triangulation for 2D polygons\n// Input: points = [[x0, y0], [x1, y1], ..., [xn, yn]] (must be simple, counter-clockwise)\n// Output: array of triangles, each as [i0, i1, i2] (indices into points)\nfunction area2(a,b,c){// Twice the signed area of triangle abc\nreturn(b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0]);}function isConvex(a,b,c){return area2(a,b,c)>0;}function pointInTriangle(p,a,b,c){// Barycentric technique\nconst area=area2(a,b,c);const area1=area2(p,b,c);const area2_=area2(a,p,c);const area3=area2(a,b,p);const s=area1/area;const t=area2_/area;const u=area3/area;return s>=0&&t>=0&&u>=0&&s<=1&&t<=1&&u<=1;}export function earclip(points){const n=points.length;if(n<3)return[];const indices=Array.from({length:n},(_,i)=>i);const triangles=[];let guard=0;while(indices.length>3&&guard++<1000){let earFound=false;for(let i=0;i<indices.length;++i){const i0=indices[(i+indices.length-1)%indices.length];const i1=indices[i];const i2=indices[(i+1)%indices.length];const a=points[i0],b=points[i1],c=points[i2];if(!isConvex(a,b,c))continue;// Check if any other point is inside triangle abc\nlet hasPointInside=false;for(let j=0;j<indices.length;++j){if(j===(i+indices.length-1)%indices.length||j===i||j===(i+1)%indices.length)continue;const p=points[indices[j]];if(pointInTriangle(p,a,b,c)){hasPointInside=true;break;}}if(hasPointInside)continue;// It's an ear\ntriangles.push([i0,i1,i2]);indices.splice(i,1);earFound=true;break;}if(!earFound)break;// No ear found, probably not simple polygon\n}// Final triangle\nif(indices.length===3){triangles.push([indices[0],indices[1],indices[2]]);}return triangles;}","map":{"version":3,"names":["area2","a","b","c","isConvex","pointInTriangle","p","area","area1","area2_","area3","s","t","u","earclip","points","n","length","indices","Array","from","_","i","triangles","guard","earFound","i0","i1","i2","hasPointInside","j","push","splice"],"sources":["/home/melvinvanelderen/TestGrass/client/src/utils/earclip.js"],"sourcesContent":["// Simple, readable ear clipping triangulation for 2D polygons\n// Input: points = [[x0, y0], [x1, y1], ..., [xn, yn]] (must be simple, counter-clockwise)\n// Output: array of triangles, each as [i0, i1, i2] (indices into points)\n\nfunction area2(a, b, c) {\n  // Twice the signed area of triangle abc\n  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n}\n\nfunction isConvex(a, b, c) {\n  return area2(a, b, c) > 0;\n}\n\nfunction pointInTriangle(p, a, b, c) {\n  // Barycentric technique\n  const area = area2(a, b, c);\n  const area1 = area2(p, b, c);\n  const area2_ = area2(a, p, c);\n  const area3 = area2(a, b, p);\n  const s = area1 / area;\n  const t = area2_ / area;\n  const u = area3 / area;\n  return s >= 0 && t >= 0 && u >= 0 && s <= 1 && t <= 1 && u <= 1;\n}\n\nexport function earclip(points) {\n  const n = points.length;\n  if (n < 3) return [];\n  const indices = Array.from({ length: n }, (_, i) => i);\n  const triangles = [];\n  let guard = 0;\n  while (indices.length > 3 && guard++ < 1000) {\n    let earFound = false;\n    for (let i = 0; i < indices.length; ++i) {\n      const i0 = indices[(i + indices.length - 1) % indices.length];\n      const i1 = indices[i];\n      const i2 = indices[(i + 1) % indices.length];\n      const a = points[i0], b = points[i1], c = points[i2];\n      if (!isConvex(a, b, c)) continue;\n      // Check if any other point is inside triangle abc\n      let hasPointInside = false;\n      for (let j = 0; j < indices.length; ++j) {\n        if (j === (i + indices.length - 1) % indices.length || j === i || j === (i + 1) % indices.length) continue;\n        const p = points[indices[j]];\n        if (pointInTriangle(p, a, b, c)) {\n          hasPointInside = true;\n          break;\n        }\n      }\n      if (hasPointInside) continue;\n      // It's an ear\n      triangles.push([i0, i1, i2]);\n      indices.splice(i, 1);\n      earFound = true;\n      break;\n    }\n    if (!earFound) break; // No ear found, probably not simple polygon\n  }\n  // Final triangle\n  if (indices.length === 3) {\n    triangles.push([indices[0], indices[1], indices[2]]);\n  }\n  return triangles;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}