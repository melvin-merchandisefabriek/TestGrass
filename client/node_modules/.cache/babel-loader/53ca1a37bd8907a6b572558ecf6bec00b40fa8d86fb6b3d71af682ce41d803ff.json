{"ast":null,"code":"/**\n * SVG path generation utility functions for Shape component\n *//**\n * Generates SVG path data for a line segment\n * @param {Object} start - Start point coordinates {x, y}\n * @param {Object} end - End point coordinates {x, y}\n * @param {boolean} isFirstSegment - Whether this is the first segment in the path\n * @returns {string} SVG path data string\n */export const generateLinePathData=function(start,end){let isFirstSegment=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(isFirstSegment){return`M ${start.x} ${start.y} L ${end.x} ${end.y}`;}return`L ${end.x} ${end.y}`;};/**\n * Generates SVG path data for a cubic bezier curve segment\n * @param {Object} start - Start point coordinates {x, y}\n * @param {Object} control1 - First control point coordinates {x, y}\n * @param {Object} control2 - Second control point coordinates {x, y}\n * @param {Object} end - End point coordinates {x, y}\n * @param {boolean} isFirstSegment - Whether this is the first segment in the path\n * @returns {string} SVG path data string\n */export const generateBezierPathData=function(start,control1,control2,end){let isFirstSegment=arguments.length>4&&arguments[4]!==undefined?arguments[4]:true;if(isFirstSegment){return`M ${start.x} ${start.y} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y}`;}return`C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y}`;};/**\n * Generates a complete SVG path from multiple segments\n * @param {Array} segments - Array of segment definitions\n * @param {Function} findPoint - Function to find a point by ID\n * @param {Function} transformPoint - Function to transform a point\n * @param {boolean} closePath - Whether to close the path\n * @returns {string} SVG path data string\n */export const generateCombinedPathData=(segments,findPoint,transformPoint,closePath)=>{let pathData='';segments.forEach((segment,index)=>{const points=segment.points.map(pointId=>transformPoint(findPoint(pointId)));const isFirstSegment=index===0;if(segment.type==='line'){const start=points[0];const end=points[1];if(isFirstSegment){pathData+=`M ${start.x} ${start.y} `;}pathData+=`L ${end.x} ${end.y} `;}else if(segment.type==='bezier'){const start=points[0];const control1=points[1];const control2=points[2];const end=points[3];if(isFirstSegment){pathData+=`M ${start.x} ${start.y} `;}pathData+=`C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;}});// If shape is marked as closed, add Z command to close the path\nif(closePath){pathData+='Z';}return pathData;};","map":{"version":3,"names":["generateLinePathData","start","end","isFirstSegment","arguments","length","undefined","x","y","generateBezierPathData","control1","control2","generateCombinedPathData","segments","findPoint","transformPoint","closePath","pathData","forEach","segment","index","points","map","pointId","type"],"sources":["/home/melvinvanelderen/TestGrass/client/src/utils/shape/pathUtils.js"],"sourcesContent":["/**\n * SVG path generation utility functions for Shape component\n */\n\n/**\n * Generates SVG path data for a line segment\n * @param {Object} start - Start point coordinates {x, y}\n * @param {Object} end - End point coordinates {x, y}\n * @param {boolean} isFirstSegment - Whether this is the first segment in the path\n * @returns {string} SVG path data string\n */\nexport const generateLinePathData = (start, end, isFirstSegment = true) => {\n  if (isFirstSegment) {\n    return `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n  }\n  return `L ${end.x} ${end.y}`;\n};\n\n/**\n * Generates SVG path data for a cubic bezier curve segment\n * @param {Object} start - Start point coordinates {x, y}\n * @param {Object} control1 - First control point coordinates {x, y}\n * @param {Object} control2 - Second control point coordinates {x, y}\n * @param {Object} end - End point coordinates {x, y}\n * @param {boolean} isFirstSegment - Whether this is the first segment in the path\n * @returns {string} SVG path data string\n */\nexport const generateBezierPathData = (start, control1, control2, end, isFirstSegment = true) => {\n  if (isFirstSegment) {\n    return `M ${start.x} ${start.y} C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y}`;\n  }\n  return `C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y}`;\n};\n\n/**\n * Generates a complete SVG path from multiple segments\n * @param {Array} segments - Array of segment definitions\n * @param {Function} findPoint - Function to find a point by ID\n * @param {Function} transformPoint - Function to transform a point\n * @param {boolean} closePath - Whether to close the path\n * @returns {string} SVG path data string\n */\nexport const generateCombinedPathData = (segments, findPoint, transformPoint, closePath) => {\n  let pathData = '';\n  \n  segments.forEach((segment, index) => {\n    const points = segment.points.map(pointId => transformPoint(findPoint(pointId)));\n    const isFirstSegment = index === 0;\n    \n    if (segment.type === 'line') {\n      const start = points[0];\n      const end = points[1];\n      \n      if (isFirstSegment) {\n        pathData += `M ${start.x} ${start.y} `;\n      }\n      pathData += `L ${end.x} ${end.y} `;\n    } else if (segment.type === 'bezier') {\n      const start = points[0];\n      const control1 = points[1];\n      const control2 = points[2];\n      const end = points[3];\n      \n      if (isFirstSegment) {\n        pathData += `M ${start.x} ${start.y} `;\n      }\n      pathData += `C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${end.x} ${end.y} `;\n    }\n  });\n  \n  // If shape is marked as closed, add Z command to close the path\n  if (closePath) {\n    pathData += 'Z';\n  }\n  \n  return pathData;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}