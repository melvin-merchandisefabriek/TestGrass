{"ast":null,"code":"/**\n * Helper utility functions for Shape component\n *//**\n * Updates animation values based on current time\n * @param {number} currentTime - Current animation time\n * @param {Object} shapeData - Shape configuration\n * @param {Object} animatedControlPoints - Current animated control points\n * @param {Object} animatedPosition - Current animated global position\n * @param {Function} setAnimatedControlPoints - Setter function for control points\n * @param {Function} setAnimatedPosition - Setter function for position\n * @param {Function} deepEquals - Deep equality comparison function\n * @param {Function} calculateControlPointPosition - Function to calculate control point position\n * @param {Function} calculateGlobalPosition - Function to calculate global position\n * @param {Function} updateAffectedSegments - Function to update affected segments\n * @param {Object} segmentRefs - References to segment DOM elements\n * @param {Object} containerRef - Reference to container DOM element\n */export const updateAnimationValues=(currentTime,shapeData,animatedControlPoints,animatedPosition,setAnimatedControlPoints,setAnimatedPosition,deepEquals,calculateControlPointPosition,calculateGlobalPosition,updateAffectedSegments,segmentRefs,containerRef)=>{var _shapeData$animations,_shapeData$animations2,_shapeData$animations3;// Track which segments need to be redrawn\nconst affectedSegments=new Set();// Process control point animations\nconst newAnimatedControlPoints={...animatedControlPoints};if((_shapeData$animations=shapeData.animations)!==null&&_shapeData$animations!==void 0&&_shapeData$animations.controlPointAnimations){Object.entries(shapeData.animations.controlPointAnimations).forEach(_ref=>{let[pointId,animation]=_ref;// Find the segments that use this control point\nshapeData.segments.forEach(segment=>{if(segment.points.includes(pointId)){affectedSegments.add(segment.id);}});// Calculate new position for this control point\nconst animatedValues=calculateControlPointPosition(pointId,animation,currentTime,shapeData.animations.duration,shapeData.controlPoints,shapeData// Pass the entire shape data to access top-level variables\n);if(animatedValues){newAnimatedControlPoints[pointId]=animatedValues;}});}// Similarly process global position animations\nlet newAnimatedPosition=animatedPosition;if((_shapeData$animations2=shapeData.animations)!==null&&_shapeData$animations2!==void 0&&(_shapeData$animations3=_shapeData$animations2.positionAnimations)!==null&&_shapeData$animations3!==void 0&&_shapeData$animations3.global){const posAnimation=shapeData.animations.positionAnimations.global;// Calculate new global position\nconst calculatedPosition=calculateGlobalPosition(posAnimation,currentTime);if(calculatedPosition){newAnimatedPosition=calculatedPosition;// All segments are affected by position changes\nshapeData.segments.forEach(segment=>{affectedSegments.add(segment.id);});}}// Update state only if the values have changed\nif(!deepEquals(animatedControlPoints,newAnimatedControlPoints)){setAnimatedControlPoints(newAnimatedControlPoints);}if(!deepEquals(animatedPosition,newAnimatedPosition)){setAnimatedPosition(newAnimatedPosition);}// Direct update of affected segments in the DOM\nupdateAffectedSegments(affectedSegments,shapeData,newAnimatedControlPoints,newAnimatedPosition,segmentRefs.current,containerRef.current);};","map":{"version":3,"names":["updateAnimationValues","currentTime","shapeData","animatedControlPoints","animatedPosition","setAnimatedControlPoints","setAnimatedPosition","deepEquals","calculateControlPointPosition","calculateGlobalPosition","updateAffectedSegments","segmentRefs","containerRef","_shapeData$animations","_shapeData$animations2","_shapeData$animations3","affectedSegments","Set","newAnimatedControlPoints","animations","controlPointAnimations","Object","entries","forEach","_ref","pointId","animation","segments","segment","points","includes","add","id","animatedValues","duration","controlPoints","newAnimatedPosition","positionAnimations","global","posAnimation","calculatedPosition","current"],"sources":["/home/melvinvanelderen/TestGrass/client/src/utils/shape/shapeHelpers.js"],"sourcesContent":["/**\n * Helper utility functions for Shape component\n */\n\n/**\n * Updates animation values based on current time\n * @param {number} currentTime - Current animation time\n * @param {Object} shapeData - Shape configuration\n * @param {Object} animatedControlPoints - Current animated control points\n * @param {Object} animatedPosition - Current animated global position\n * @param {Function} setAnimatedControlPoints - Setter function for control points\n * @param {Function} setAnimatedPosition - Setter function for position\n * @param {Function} deepEquals - Deep equality comparison function\n * @param {Function} calculateControlPointPosition - Function to calculate control point position\n * @param {Function} calculateGlobalPosition - Function to calculate global position\n * @param {Function} updateAffectedSegments - Function to update affected segments\n * @param {Object} segmentRefs - References to segment DOM elements\n * @param {Object} containerRef - Reference to container DOM element\n */\nexport const updateAnimationValues = (\n  currentTime,\n  shapeData,\n  animatedControlPoints,\n  animatedPosition,\n  setAnimatedControlPoints,\n  setAnimatedPosition,\n  deepEquals,\n  calculateControlPointPosition,\n  calculateGlobalPosition,\n  updateAffectedSegments,\n  segmentRefs,\n  containerRef\n) => {\n  // Track which segments need to be redrawn\n  const affectedSegments = new Set();\n  \n  // Process control point animations\n  const newAnimatedControlPoints = { ...animatedControlPoints };\n  \n  if (shapeData.animations?.controlPointAnimations) {\n    Object.entries(shapeData.animations.controlPointAnimations).forEach(([pointId, animation]) => {\n      // Find the segments that use this control point\n      shapeData.segments.forEach(segment => {\n        if (segment.points.includes(pointId)) {\n          affectedSegments.add(segment.id);\n        }\n      });\n      \n      // Calculate new position for this control point\n      const animatedValues = calculateControlPointPosition(\n        pointId, \n        animation, \n        currentTime, \n        shapeData.animations.duration, \n        shapeData.controlPoints,\n        shapeData  // Pass the entire shape data to access top-level variables\n      );\n      if (animatedValues) {\n        newAnimatedControlPoints[pointId] = animatedValues;\n      }\n    });\n  }\n  \n  // Similarly process global position animations\n  let newAnimatedPosition = animatedPosition;\n  if (shapeData.animations?.positionAnimations?.global) {\n    const posAnimation = shapeData.animations.positionAnimations.global;\n    \n    // Calculate new global position\n    const calculatedPosition = calculateGlobalPosition(posAnimation, currentTime);\n    if (calculatedPosition) {\n      newAnimatedPosition = calculatedPosition;\n      \n      // All segments are affected by position changes\n      shapeData.segments.forEach(segment => {\n        affectedSegments.add(segment.id);\n      });\n    }\n  }\n  \n  // Update state only if the values have changed\n  if (!deepEquals(animatedControlPoints, newAnimatedControlPoints)) {\n    setAnimatedControlPoints(newAnimatedControlPoints);\n  }\n  \n  if (!deepEquals(animatedPosition, newAnimatedPosition)) {\n    setAnimatedPosition(newAnimatedPosition);\n  }\n  \n  // Direct update of affected segments in the DOM\n  updateAffectedSegments(\n    affectedSegments, \n    shapeData, \n    newAnimatedControlPoints, \n    newAnimatedPosition, \n    segmentRefs.current, \n    containerRef.current\n  );\n};\n"],"mappings":"AAAA;AACA;AACA,GAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAA,qBAAqB,CAAGA,CACnCC,WAAW,CACXC,SAAS,CACTC,qBAAqB,CACrBC,gBAAgB,CAChBC,wBAAwB,CACxBC,mBAAmB,CACnBC,UAAU,CACVC,6BAA6B,CAC7BC,uBAAuB,CACvBC,sBAAsB,CACtBC,WAAW,CACXC,YAAY,GACT,KAAAC,qBAAA,CAAAC,sBAAA,CAAAC,sBAAA,CACH;AACA,KAAM,CAAAC,gBAAgB,CAAG,GAAI,CAAAC,GAAG,CAAC,CAAC,CAElC;AACA,KAAM,CAAAC,wBAAwB,CAAG,CAAE,GAAGf,qBAAsB,CAAC,CAE7D,IAAAU,qBAAA,CAAIX,SAAS,CAACiB,UAAU,UAAAN,qBAAA,WAApBA,qBAAA,CAAsBO,sBAAsB,CAAE,CAChDC,MAAM,CAACC,OAAO,CAACpB,SAAS,CAACiB,UAAU,CAACC,sBAAsB,CAAC,CAACG,OAAO,CAACC,IAAA,EAA0B,IAAzB,CAACC,OAAO,CAAEC,SAAS,CAAC,CAAAF,IAAA,CACvF;AACAtB,SAAS,CAACyB,QAAQ,CAACJ,OAAO,CAACK,OAAO,EAAI,CACpC,GAAIA,OAAO,CAACC,MAAM,CAACC,QAAQ,CAACL,OAAO,CAAC,CAAE,CACpCT,gBAAgB,CAACe,GAAG,CAACH,OAAO,CAACI,EAAE,CAAC,CAClC,CACF,CAAC,CAAC,CAEF;AACA,KAAM,CAAAC,cAAc,CAAGzB,6BAA6B,CAClDiB,OAAO,CACPC,SAAS,CACTzB,WAAW,CACXC,SAAS,CAACiB,UAAU,CAACe,QAAQ,CAC7BhC,SAAS,CAACiC,aAAa,CACvBjC,SAAW;AACb,CAAC,CACD,GAAI+B,cAAc,CAAE,CAClBf,wBAAwB,CAACO,OAAO,CAAC,CAAGQ,cAAc,CACpD,CACF,CAAC,CAAC,CACJ,CAEA;AACA,GAAI,CAAAG,mBAAmB,CAAGhC,gBAAgB,CAC1C,IAAAU,sBAAA,CAAIZ,SAAS,CAACiB,UAAU,UAAAL,sBAAA,YAAAC,sBAAA,CAApBD,sBAAA,CAAsBuB,kBAAkB,UAAAtB,sBAAA,WAAxCA,sBAAA,CAA0CuB,MAAM,CAAE,CACpD,KAAM,CAAAC,YAAY,CAAGrC,SAAS,CAACiB,UAAU,CAACkB,kBAAkB,CAACC,MAAM,CAEnE;AACA,KAAM,CAAAE,kBAAkB,CAAG/B,uBAAuB,CAAC8B,YAAY,CAAEtC,WAAW,CAAC,CAC7E,GAAIuC,kBAAkB,CAAE,CACtBJ,mBAAmB,CAAGI,kBAAkB,CAExC;AACAtC,SAAS,CAACyB,QAAQ,CAACJ,OAAO,CAACK,OAAO,EAAI,CACpCZ,gBAAgB,CAACe,GAAG,CAACH,OAAO,CAACI,EAAE,CAAC,CAClC,CAAC,CAAC,CACJ,CACF,CAEA;AACA,GAAI,CAACzB,UAAU,CAACJ,qBAAqB,CAAEe,wBAAwB,CAAC,CAAE,CAChEb,wBAAwB,CAACa,wBAAwB,CAAC,CACpD,CAEA,GAAI,CAACX,UAAU,CAACH,gBAAgB,CAAEgC,mBAAmB,CAAC,CAAE,CACtD9B,mBAAmB,CAAC8B,mBAAmB,CAAC,CAC1C,CAEA;AACA1B,sBAAsB,CACpBM,gBAAgB,CAChBd,SAAS,CACTgB,wBAAwB,CACxBkB,mBAAmB,CACnBzB,WAAW,CAAC8B,OAAO,CACnB7B,YAAY,CAAC6B,OACf,CAAC,CACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}