{"ast":null,"code":"import{substituteVariables,deepClone}from'./variableUtils';/**\n * Utilities for loading and processing shape data\n *//**\n * Processes numeric values that might be mathematical expressions in the JSON data\n * Example: Converting serialized PI values back to Math.PI\n * @param {Object} data - JSON data that needs processing\n * @returns {Object} - Processed data with mathematical values evaluated\n */export const processNumericValues=data=>{var _processedData$animat;// Deep clone the data to avoid mutations\nconst processedData=deepClone(data);// Process special PI values in animation formulas\nif((_processedData$animat=processedData.animations)!==null&&_processedData$animat!==void 0&&_processedData$animat.controlPointAnimations){Object.entries(processedData.animations.controlPointAnimations).forEach(_ref=>{var _animation$formula,_animation$formula$y,_animation$formula$y$;let[pointId,animation]=_ref;if(animation!==null&&animation!==void 0&&(_animation$formula=animation.formula)!==null&&_animation$formula!==void 0&&(_animation$formula$y=_animation$formula.y)!==null&&_animation$formula$y!==void 0&&(_animation$formula$y$=_animation$formula$y.variables)!==null&&_animation$formula$y$!==void 0&&_animation$formula$y$.phase){// Convert known PI values back to actual Math values\nif(animation.formula.y.variables.phase.toString()===\"1.5707963267948966\"){animation.formula.y.variables.phase=Math.PI/2;}else if(animation.formula.y.variables.phase.toString()===\"3.141592653589793\"){animation.formula.y.variables.phase=Math.PI;}else if(animation.formula.y.variables.phase.toString()===\"6.283185307179586\"){animation.formula.y.variables.phase=Math.PI*2;}}});}return processedData;};/**\n * Converts a hex color code to rgba format\n * @param {string} hex - The hex color code (with or without #)\n *                     - Can be 3 digits (#RGB), 6 digits (#RRGGBB), or 8 digits (#RRGGBBAA)\n * @returns {string} - The rgba color string (e.g., \"rgba(255, 0, 0, 0.5)\")\n */export const hexToRgba=hex=>{// Remove the hash if it exists\nlet cleanHex=hex.replace(/^#/,'');let hexAlpha=1;// Default alpha is 1 (fully opaque)\n// Handle hex with alpha included (8 digits)\nif(cleanHex.length===8){hexAlpha=parseInt(cleanHex.substr(6,2),16)/255;cleanHex=cleanHex.substr(0,6);}// Handle shorthand hex (e.g., #FFF)\nif(cleanHex.length===3){cleanHex=cleanHex.split('').map(char=>char+char).join('');}// Parse the hex values\nconst r=parseInt(cleanHex.substr(0,2),16);const g=parseInt(cleanHex.substr(2,2),16);const b=parseInt(cleanHex.substr(4,2),16);// Ensure alpha is within valid range\nconst validAlpha=Math.max(0,Math.min(1,hexAlpha));// Return rgba string\nreturn`rgba(${r}, ${g}, ${b}, ${validAlpha})`;};/**\n * Processes color values in shape data, converting hex to rgba when needed\n * @param {Object} shapeData - The shape data object\n * @returns {Object} - Updated shape data with converted colors\n */export const processColors=shapeData=>{// Create a deep copy to avoid mutating the original\nconst processedData=JSON.parse(JSON.stringify(shapeData));// Helper function to process any color property\nconst processColorProperty=(styleObj,property)=>{if(styleObj&&styleObj[property]&&typeof styleObj[property]==='string'&&styleObj[property].startsWith('#')){// For fill/stroke, check if there's an opacity property\nconst opacityProp=`${property}Opacity`;// If we have an opacity property, append it to the hex code\nif(styleObj[opacityProp]!==undefined){// Convert opacity (0-1) to hex (00-FF)\nconst alphaHex=Math.round(styleObj[opacityProp]*255).toString(16).padStart(2,'0').toUpperCase();// Remove any existing hash\nconst baseHex=styleObj[property].replace(/^#/,'');// If it's already an 8-digit hex, don't modify\nif(baseHex.length!==8){// Handle shorthand hex\nconst fullHex=baseHex.length===3?baseHex.split('').map(c=>c+c).join(''):baseHex;// Create new hex with alpha\nstyleObj[property]='#'+fullHex+alphaHex;}// Remove opacity property as it's now incorporated in the hex\ndelete styleObj[opacityProp];}// Convert the hex (with or without alpha) to rgba\nstyleObj[property]=hexToRgba(styleObj[property]);}};// Process style for the main shape\nif(processedData.style){processColorProperty(processedData.style,'fill');processColorProperty(processedData.style,'stroke');}// Process styles for individual segments\nif(processedData.segments){processedData.segments.forEach(segment=>{if(segment.style){processColorProperty(segment.style,'fill');processColorProperty(segment.style,'stroke');}});}return processedData;};/**\n * Loads shape data from a JSON file path\n * @param {string} filePath - Path to the JSON file\n * @returns {Promise<Object>} - Shape data object with processed values\n */export const loadShapeData=async filePath=>{try{// Use fetch API to load the JSON file which works better with relative paths\nconst response=await fetch(filePath);if(!response.ok){throw new Error(`Failed to fetch shape data: ${response.statusText}`);}const shapeData=await response.json();const dataWithVariables=processExpressionVariables(shapeData);// Process any special values in the data\nconst dataWithNumericValues=processNumericValues(dataWithVariables);// Process color values (by default, don't auto-process colors - set to true if needed)\nconst autoProcessColors=false;return autoProcessColors?processColors(dataWithNumericValues):dataWithNumericValues;}catch(error){console.error('Error loading shape data:',error);throw new Error(`Failed to load shape data from ${filePath}`);}};/**\n * Processes expression variables using the |var:variableName| syntax\n * Replaces variable references with their values from the top-level variables object\n * @param {Object} data - JSON data that needs processing\n * @returns {Object} - Processed data with variable references replaced\n */export const processExpressionVariables=data=>{const processedData=deepClone(data);if(!processedData.variables)return processedData;const variableLookup={};if(Array.isArray(processedData.variables)){processedData.variables.forEach(varObj=>{const key=Object.keys(varObj)[0];variableLookup[key]=varObj[key];});}else if(typeof processedData.variables==='object'){Object.assign(variableLookup,processedData.variables);}const processObject=obj=>{if(!obj||typeof obj!=='object')return;Object.entries(obj).forEach(_ref2=>{let[key,value]=_ref2;if(typeof value==='string'){const updatedValue=substituteVariables(value,variableLookup);if(updatedValue!==value)obj[key]=updatedValue;}else if(typeof value==='object'&&value!==null){processObject(value);}});};const{variables,...dataToProcess}=processedData;processObject(dataToProcess);return{variables,...dataToProcess};};/**\n * Creates a variable reference string using the |var:name| syntax\n * @param {string} varName - The name of the variable to reference\n * @returns {string} - Formatted variable reference\n * \n * @example\n * // Returns \"|var:myVariable|\"\n * varRef('myVariable')\n */export const varRef=varName=>{return`|var:${varName}|`;};","map":{"version":3,"names":["substituteVariables","deepClone","processNumericValues","data","_processedData$animat","processedData","animations","controlPointAnimations","Object","entries","forEach","_ref","_animation$formula","_animation$formula$y","_animation$formula$y$","pointId","animation","formula","y","variables","phase","toString","Math","PI","hexToRgba","hex","cleanHex","replace","hexAlpha","length","parseInt","substr","split","map","char","join","r","g","b","validAlpha","max","min","processColors","shapeData","JSON","parse","stringify","processColorProperty","styleObj","property","startsWith","opacityProp","undefined","alphaHex","round","padStart","toUpperCase","baseHex","fullHex","c","style","segments","segment","loadShapeData","filePath","response","fetch","ok","Error","statusText","json","dataWithVariables","processExpressionVariables","dataWithNumericValues","autoProcessColors","error","console","variableLookup","Array","isArray","varObj","key","keys","assign","processObject","obj","_ref2","value","updatedValue","dataToProcess","varRef","varName"],"sources":["/home/melvinvanelderen/TestGrass/client/src/utils/shape/dataUtils.js"],"sourcesContent":["import { substituteVariables, deepClone } from './variableUtils';\n\n/**\n * Utilities for loading and processing shape data\n */\n\n/**\n * Processes numeric values that might be mathematical expressions in the JSON data\n * Example: Converting serialized PI values back to Math.PI\n * @param {Object} data - JSON data that needs processing\n * @returns {Object} - Processed data with mathematical values evaluated\n */\nexport const processNumericValues = (data) => {\n  // Deep clone the data to avoid mutations\n  const processedData = deepClone(data);\n\n  // Process special PI values in animation formulas\n  if (processedData.animations?.controlPointAnimations) {\n    Object.entries(processedData.animations.controlPointAnimations).forEach(([pointId, animation]) => {\n      if (animation?.formula?.y?.variables?.phase) {\n        // Convert known PI values back to actual Math values\n        if (animation.formula.y.variables.phase.toString() === \"1.5707963267948966\") {\n          animation.formula.y.variables.phase = Math.PI / 2;\n        } else if (animation.formula.y.variables.phase.toString() === \"3.141592653589793\") {\n          animation.formula.y.variables.phase = Math.PI;\n        } else if (animation.formula.y.variables.phase.toString() === \"6.283185307179586\") {\n          animation.formula.y.variables.phase = Math.PI * 2;\n        }\n      }\n    });\n  }\n\n  return processedData;\n};\n\n/**\n * Converts a hex color code to rgba format\n * @param {string} hex - The hex color code (with or without #)\n *                     - Can be 3 digits (#RGB), 6 digits (#RRGGBB), or 8 digits (#RRGGBBAA)\n * @returns {string} - The rgba color string (e.g., \"rgba(255, 0, 0, 0.5)\")\n */\nexport const hexToRgba = (hex) => {\n  // Remove the hash if it exists\n  let cleanHex = hex.replace(/^#/, '');\n  let hexAlpha = 1; // Default alpha is 1 (fully opaque)\n  \n  // Handle hex with alpha included (8 digits)\n  if (cleanHex.length === 8) {\n    hexAlpha = parseInt(cleanHex.substr(6, 2), 16) / 255;\n    cleanHex = cleanHex.substr(0, 6);\n  }\n  \n  // Handle shorthand hex (e.g., #FFF)\n  if (cleanHex.length === 3) {\n    cleanHex = cleanHex\n      .split('')\n      .map(char => char + char)\n      .join('');\n  }\n  \n  // Parse the hex values\n  const r = parseInt(cleanHex.substr(0, 2), 16);\n  const g = parseInt(cleanHex.substr(2, 2), 16);\n  const b = parseInt(cleanHex.substr(4, 2), 16);\n  \n  // Ensure alpha is within valid range\n  const validAlpha = Math.max(0, Math.min(1, hexAlpha));\n  \n  // Return rgba string\n  return `rgba(${r}, ${g}, ${b}, ${validAlpha})`;\n};\n\n/**\n * Processes color values in shape data, converting hex to rgba when needed\n * @param {Object} shapeData - The shape data object\n * @returns {Object} - Updated shape data with converted colors\n */\nexport const processColors = (shapeData) => {\n  // Create a deep copy to avoid mutating the original\n  const processedData = JSON.parse(JSON.stringify(shapeData));\n  \n  // Helper function to process any color property\n  const processColorProperty = (styleObj, property) => {\n    if (styleObj && styleObj[property] && typeof styleObj[property] === 'string' && styleObj[property].startsWith('#')) {\n      // For fill/stroke, check if there's an opacity property\n      const opacityProp = `${property}Opacity`;\n      \n      // If we have an opacity property, append it to the hex code\n      if (styleObj[opacityProp] !== undefined) {\n        // Convert opacity (0-1) to hex (00-FF)\n        const alphaHex = Math.round(styleObj[opacityProp] * 255)\n          .toString(16)\n          .padStart(2, '0')\n          .toUpperCase();\n          \n        // Remove any existing hash\n        const baseHex = styleObj[property].replace(/^#/, '');\n        \n        // If it's already an 8-digit hex, don't modify\n        if (baseHex.length !== 8) {\n          // Handle shorthand hex\n          const fullHex = baseHex.length === 3 \n            ? baseHex.split('').map(c => c + c).join('')\n            : baseHex;\n            \n          // Create new hex with alpha\n          styleObj[property] = '#' + fullHex + alphaHex;\n        }\n        \n        // Remove opacity property as it's now incorporated in the hex\n        delete styleObj[opacityProp];\n      }\n      \n      // Convert the hex (with or without alpha) to rgba\n      styleObj[property] = hexToRgba(styleObj[property]);\n    }\n  };\n  \n  // Process style for the main shape\n  if (processedData.style) {\n    processColorProperty(processedData.style, 'fill');\n    processColorProperty(processedData.style, 'stroke');\n  }\n  \n  // Process styles for individual segments\n  if (processedData.segments) {\n    processedData.segments.forEach(segment => {\n      if (segment.style) {\n        processColorProperty(segment.style, 'fill');\n        processColorProperty(segment.style, 'stroke');\n      }\n    });\n  }\n  \n  return processedData;\n};\n\n/**\n * Loads shape data from a JSON file path\n * @param {string} filePath - Path to the JSON file\n * @returns {Promise<Object>} - Shape data object with processed values\n */\nexport const loadShapeData = async (filePath) => {\n  try {\n    // Use fetch API to load the JSON file which works better with relative paths\n    const response = await fetch(filePath);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch shape data: ${response.statusText}`);\n    }\n    \n    const shapeData = await response.json();\n    \n\n    \n    const dataWithVariables = processExpressionVariables(shapeData);\n\n    // Process any special values in the data\n    const dataWithNumericValues = processNumericValues(dataWithVariables);\n    \n    // Process color values (by default, don't auto-process colors - set to true if needed)\n    const autoProcessColors = false;\n    return autoProcessColors ? processColors(dataWithNumericValues) : dataWithNumericValues;\n  } catch (error) {\n    console.error('Error loading shape data:', error);\n    throw new Error(`Failed to load shape data from ${filePath}`);\n  }\n};\n\n/**\n * Processes expression variables using the |var:variableName| syntax\n * Replaces variable references with their values from the top-level variables object\n * @param {Object} data - JSON data that needs processing\n * @returns {Object} - Processed data with variable references replaced\n */\nexport const processExpressionVariables = (data) => {\n  const processedData = deepClone(data);\n  if (!processedData.variables) return processedData;\n  const variableLookup = {};\n  if (Array.isArray(processedData.variables)) {\n    processedData.variables.forEach(varObj => {\n      const key = Object.keys(varObj)[0];\n      variableLookup[key] = varObj[key];\n    });\n  } else if (typeof processedData.variables === 'object') {\n    Object.assign(variableLookup, processedData.variables);\n  }\n  const processObject = (obj) => {\n    if (!obj || typeof obj !== 'object') return;\n    Object.entries(obj).forEach(([key, value]) => {\n      if (typeof value === 'string') {\n        const updatedValue = substituteVariables(value, variableLookup);\n        if (updatedValue !== value) obj[key] = updatedValue;\n      } else if (typeof value === 'object' && value !== null) {\n        processObject(value);\n      }\n    });\n  };\n  const { variables, ...dataToProcess } = processedData;\n  processObject(dataToProcess);\n  return { variables, ...dataToProcess };\n};\n\n/**\n * Creates a variable reference string using the |var:name| syntax\n * @param {string} varName - The name of the variable to reference\n * @returns {string} - Formatted variable reference\n * \n * @example\n * // Returns \"|var:myVariable|\"\n * varRef('myVariable')\n */\nexport const varRef = (varName) => {\n  return `|var:${varName}|`;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}