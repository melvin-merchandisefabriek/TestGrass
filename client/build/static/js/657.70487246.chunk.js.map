{"version":3,"file":"static/js/657.70487246.chunk.js","mappings":"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","sources":["utils/shape/modificationUtils.js"],"sourcesContent":["/**\n * Utility functions for handling shape modifications from external sources\n */\n\n/**\n * Applies modifications from a modifications object to a shape\n * @param {Object} shape - The original shape object\n * @param {Object} modifications - Modification specifications\n * @returns {Object} Modified shape object\n */\nexport const applyShapeModifications = (shape, modifications) => {\n  if (!shape || !modifications) return shape;\n  \n  // Create a deep copy to avoid mutating the original\n  const modifiedShape = JSON.parse(JSON.stringify(shape));\n  \n  // Apply position modifications\n  if (modifications.modifyPosition) {\n    // Support svg and global keys for unified SVG logic\n    if (modifications.modifyPosition.svg) {\n      if (!modifiedShape.position) modifiedShape.position = {};\n      modifiedShape.position.svg = { ...modifications.modifyPosition.svg };\n    }\n    if (modifications.modifyPosition.global) {\n      if (!modifiedShape.position) modifiedShape.position = {};\n      modifiedShape.position.global = { ...modifications.modifyPosition.global };\n    }\n    // Legacy: if x/y provided at top level, apply to global\n    if (typeof modifications.modifyPosition.x === 'number' || typeof modifications.modifyPosition.y === 'number') {\n      if (modifiedShape.position?.global) {\n        modifiedShape.position.global.x += modifications.modifyPosition.x || 0;\n        modifiedShape.position.global.y += modifications.modifyPosition.y || 0;\n      }\n    }\n  }\n  \n  // Apply control point modifications\n  if (modifications.modifyControlPoints) {\n    Object.entries(modifications.modifyControlPoints).forEach(([pointId, changes]) => {\n      const controlPoint = modifiedShape.controlPoints.find(point => point.id === pointId);\n      if (controlPoint) {\n        if (changes.xOffset) controlPoint.x += changes.xOffset;\n        if (changes.yOffset) controlPoint.y += changes.yOffset;\n      }\n    });\n  }\n  \n  // Apply style modifications\n  if (modifications.styleChanges) {\n    Object.entries(modifications.styleChanges).forEach(([segmentId, newStyle]) => {\n      const segment = modifiedShape.segments.find(seg => seg.id === segmentId);\n      if (segment) {\n        segment.style = { ...segment.style, ...newStyle };\n      }\n    });\n  }\n  \n  // Apply main style from modifications if present\n  if (modifications.style) {\n    modifiedShape.style = { ...modifiedShape.style, ...modifications.style };\n  }\n  \n  // Apply fillPath and closePath from modifications if present\n  if (typeof modifications.fillPath !== 'undefined') {\n    modifiedShape.fillPath = modifications.fillPath;\n  }\n  \n  if (typeof modifications.closePath !== 'undefined') {\n    modifiedShape.closePath = modifications.closePath;\n  }\n  \n  // Copy viewBox if present in modifications\n  if (modifications.viewBox) {\n    modifiedShape.viewBox = modifications.viewBox;\n  }\n  \n  // Copy width and height if present in modifications\n  if (typeof modifications.width !== 'undefined') {\n    modifiedShape.width = modifications.width;\n  }\n  \n  if (typeof modifications.height !== 'undefined') {\n    modifiedShape.height = modifications.height;\n  }\n  \n  // Apply display options from modifications if present\n  if (modifications.displayOptions) {\n    modifiedShape.displayOptions = {\n      ...modifiedShape.displayOptions || {},\n      ...modifications.displayOptions\n    };\n  }\n  \n  // --- Merge or preserve variables field ---\n  if (shape.variables || modifications.variables) {\n    // Support both array and object forms\n    let baseVars = shape.variables || [];\n    let modVars = modifications.variables || [];\n    // Convert to array of objects if needed\n    if (!Array.isArray(baseVars)) baseVars = [baseVars];\n    if (!Array.isArray(modVars)) modVars = [modVars];\n    // Merge arrays, with modifications taking precedence for duplicate keys\n    const varMap = {};\n    baseVars.forEach(obj => {\n      const key = Object.keys(obj)[0];\n      varMap[key] = obj[key];\n    });\n    modVars.forEach(obj => {\n      const key = Object.keys(obj)[0];\n      varMap[key] = obj[key];\n    });\n    // Rebuild as array of objects\n    modifiedShape.variables = Object.entries(varMap).map(([k, v]) => ({ [k]: v }));\n  }\n  \n  // Process style templates with animation variables\n  if (modifications.style) {\n    // Process each style property for template expressions\n    Object.keys(modifications.style).forEach(key => {\n      const value = modifications.style[key];\n      if (typeof value === 'string' && value.includes('${')) {\n        // This is a template string that needs to be processed during animation\n        if (!modifications.animations) {\n          modifications.animations = { styleAnimations: {} };\n        } else if (!modifications.animations.styleAnimations) {\n          modifications.animations.styleAnimations = {};\n        }\n        \n        // Store this as a style animation expression\n        modifications.animations.styleAnimations[key] = value;\n        \n        // For the initial value, use a placeholder\n        modifications.style[key] = value.replace(/\\${(.*?)}/g, '0');\n      }\n    });\n  }\n  \n  // Set up animations from the modifications\n  if (modifications.animations) {\n    // Create or update animations structure in the shape data\n    modifiedShape.animations = {\n      duration: modifications.animations.duration || 5,\n      loops: modifications.animations.loops || 0,\n      controlPointAnimations: {},\n      styleAnimations: modifications.animations.styleAnimations || {}\n    };\n    \n    // Copy control point animations directly from the modifications\n    if (modifications.animations.controlPointAnimations) {\n      // Just directly copy the control point animations - no special handling needed\n      // since we're only using expressions now\n      modifiedShape.animations.controlPointAnimations = JSON.parse(\n        JSON.stringify(modifications.animations.controlPointAnimations)\n      );\n    }\n    \n    // Add position animations if present\n    if (modifications.animations.positionAnimations) {\n      modifiedShape.animations.positionAnimations = \n        JSON.parse(JSON.stringify(modifications.animations.positionAnimations));\n    }\n    \n    // Copy style animations if present\n    if (modifications.animations.styleAnimations) {\n      modifiedShape.animations.styleAnimations = \n        JSON.parse(JSON.stringify(modifications.animations.styleAnimations));\n    }\n  }\n  \n  return modifiedShape;\n};\n\n/**\n * Loads modifications from a modifications file\n * @param {string} modPath - Path to the modifications JSON file\n * @returns {Promise<Object>} - The loaded modifications\n */\nexport const loadModifications = async (modPath) => {\n  try {\n    const response = await fetch(modPath);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to load modifications: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error loading modifications:', error);\n    return null;\n  }\n};\n"],"names":["applyShapeModifications","shape","modifications","modifiedShape","JSON","parse","stringify","_modifiedShape$positi","modifyPosition","svg","position","global","x","y","modifyControlPoints","Object","entries","forEach","_ref","pointId","changes","controlPoint","controlPoints","find","point","id","xOffset","yOffset","styleChanges","_ref2","segmentId","newStyle","segment","segments","seg","style","fillPath","closePath","viewBox","width","height","displayOptions","variables","baseVars","modVars","Array","isArray","varMap","obj","key","keys","map","_ref3","k","v","value","includes","animations","styleAnimations","replace","duration","loops","controlPointAnimations","positionAnimations","loadModifications","async","response","fetch","modPath","ok","Error","status","json","error","console"],"sourceRoot":""}